![image](https://github.com/user-attachments/assets/a022fada-ad26-41ce-a9b3-311f8a8dfe66)

## function
- str(문자열, 시작 인덱스): 문자열에서 시작 인덱스 위치부터 끝까지 자름
```sql
select substr('Hello, SQL',7) from dual;
# 공백도 문자. 자를 문자 개수를 지정하지 않으면 끝까지 출력
```
```sql
# emp 테이블에서 ename의 두 번째 문자를 '*'로 바꿔서 출력
select replace(ename,str(ename, 2, 1), '*') from emp;
```
- nvl(var, value): var의 값(컬럼 이름)이 null이면 value를 반환(return)하고, 그렇지 않으면 var를 반환
```sql
select comm, nvl(comm, -1) from emp;
```
- nvl2(var, value1, value2): var의 값이 null이 아니면 value1을 반환하고, null이면 value2를 반환
```sql
select comm, nvl2(comm, 9999, 0) from emp;
```
```sql
# 사번, 이름, 급여, 수당, 연봉(sal * 12 + comm). comm이 null인 경우는 comm을 0으로 계산
select empno, ename, sal, comm, (nvl(sal,0)*12+nvl(comm, 0)) as "ANUAL_SAL"
from emp
order by ANUAL_SAL desc;  # select에서 설정한 alias(별명)을 order by에서 사용 가능
```

- round(arg): arg(숫자 타입)의 소숫점 첫 번째 자리에서 반올림
- round(arg, 양의 정수): 양의 정수까지의 소숫점 이하 자리를 표현
```sql
select
  10/3,  # 3.333...
  round(10/3),  # 3
  round(10/3,1),  # 3.3
  round(10/3,2)  # 3.33
from dual;  # 테이블 이름이 없을 땐 dual
```
- round(arg, 음의 정수): 정수 자릿수에서 반올림
```sql
select round(153, -1), round(153, -2) from dual;  # 결과(150, 200)
```
- trunc(): 버림
```spl
select trunc(3.141592, 2), trunc(3.141592, 3) from dual;  # trunc는 무조건 잘라버림. 결과(3.14, 3.141)
```

- decode(var, value1, ret_val1, ret_val2):
  - var의 값이 value와 같으면 ret_val1을 반환, 그렇지 않으면 ret_val2을 반환
  - null은 decode에서 사용할 수 없음
```sql
# 부서 번호가 10이면 보너스 1000, 그렇지 않으면 0
select ename, deptno, decode(deptno, 10, 1000, 0) as "BONUS"
from dual;
``` 
- decode(var, value1, ret_val1 value2, ret_val2, ret_val3)
  - var의 값이 value1이면 ret_val1을 반환(if var = value1: bonus = ret_val1)
  - var의 값이 value2이면 ret_val2을 반환(else if var = value2: bonus = ret_val2)
  - 그렇지 않으면 ret_val3을 반환(else bonus = ret_val3)
```sql
# 10번 부서는 보너스 1000, 20번 부서는 보너스 500, 30번 부서는 100, 그 이외에는 0
select
  ename, deptno,
  decode(deptno, 10, 1000, 20, 500, 30, 100, 0) as "BONUS"
from emp;
```

- case-when-end 구문: decode() 함수를 대신할 수 있는 구문
```sql
select
  enams, deptno
  case when deptno = 10 then 1000
       when deptno = 20 then 500
       when deptno = 30 then 100
       else 0
  end as "BONUS"
from emp;
```
```sql
# 급여가 3000 이상이면 보너스 100, 2000 이상이면 보너스 110, 급여가 1000 이상이면 보너스 150, 나머지는 보너스 200
select
  ename, deptno, sal,
  case when sal >= 3000 then 100
       when sal >= 2000 then 110
       when sal >= 1000 then 150
       else 200
  end as "BONUS"
from emp;
```

# function_groupby
- 다중 행 함수: 여러 개의 행들이 함수 아규먼트로 전달되고, 하나의 값을 반환하는 함수
- 통계 함수: count, sum, avg, ...
  - count(var): var(컬럼)에서 null이 아닌 값들의 개수를 반환
  - 다중 행 함수는 행이 하나만 나옴

```sql
select count(*) from emp;  # 테이블의 행 개수 반환
```
  - 통계 함수: null을 제외하고 계산
  - sum(): 합계
  - avg(): average, 평균
  - variance(): 분산
  - stddev(): standard deviation, 표준편차
  - max(): 최댓값
  - min(): 최솟값
```sql
select 
  count(sal) as “개수”,
  sum(sal) as “합계”,
  round(avg(sal), 2) as “평균”,
  round(variance(sal), 2) as “분산”,
  round(stddev(sal), 2) as “표준편차”,
  max(sal) as “최댓값”,
  min(sal) as “최솟값”
from emp;
``` 
- 통계량: 여러 개의 자료들을 하나의 숫자로 표현
  - 평균 = 합/개수
  - A: 100 200 300 -> 600/3 = 200, B: 50 50 500 -> 600/3 = 200
  - B가 분산이 더 큼. 분산은 평균에서 얼마나 떨어져 있는지

- 단일 행 함수와 다중 행 함수(그룹 함수)는 함께 사용할 수 없음
```
select count(comm), nvl(comm, 0) from emp; -> 에러 발생
select empno, count(empno) from emp; -> 에러 발생생
```
- 그룹별 쿼리
  - 예) 부서별 급여 평균, 부서별 직원수, ...
  - 순서 지켜줘야 하고, select와 from은 생략할 수 없음
  - select 컬럼, 함수, ...  # 5
  - from 테이블, ...  # 1
  - where 조건식(1)  # 2
  - group by 컬럼(그룹을 묶을 수 있는 변수), ...  # 3
  - having 조건식(2)  # 4
  - order by 컬럼(정렬 기준이 되는 변수), ...;  # 6
<br>
  - where 조건식(1): 그룹을 묶기 전에 조건을 만족하는 행들을 선택하기 위한 조건식
  - having 조건식(2): 그룹을 묶은 후에 조건을 만족하는 그룹들을 선택하기 위한 조건식
  - (주의) group by에서 지정하지 않은 컬럼 이름은 select할 수 없음

```sql
# 부서별 인원수
select deptno, count(*)  # 3
from emp  # 1
group by deptno  # 2
order by deptno;  # 4
```
```sql
# 부서별 급여 평균
select deptno, round(avg(sal),2) as "AVG_SAL"
from emp
group by deptno
order by deptno;
```
```sql
# 급여가 null이 아닌 직원들 중에서 부서별 급여 평균
select deptno, round(avg(sal), 2) as "AVG_SAL"
from emp
where sal is not null
group by deptno
order by deptno;
```
```sql
# 급여가 null이 아닌 직원들 중에서 부서별 직원수, 급여 평균/최솟값/최댓값
select
  deptno,
  count(deptno) as "COUNT_EMP",  # count(*)도 가능
  round(avg(sal), 2) as "AVG_SAL",
  min(sal) as "MIN_SAL",
  max(sal) as "MAX_SAL"
from emp
where sal is not null
group by deptno
order by deptno;
```
```sql
# 업무가 null이 아닌 직원들 중에서 업무별 직원수, 급여 평균/표준편차
select
  job,
  count(*) as "COUNT_EMP",
  round(avg(sal), 2) as "AVG_SAL",
  round(stddev(sal), 2) as "STD_SAL"
from emp
where job is not null
group by job
order by job;
```
```sql
# 부서별 업무별 직원수, 급여 평균/최솟값/최댓값. 업무가 null인 직원, 급여가 null인 직원은 제외
select
  deptno, job,
  round(avg(sal), 2) as "AVG_SAL",
  min(sal) as "MIN_SAL",
  max(sal) as "MAX_SAL"
from emp
where (job is not null) and (sal is not null)  # where not (job is null or sal is null)랑 같은 식
group by deptno, job
order by deptno, job;
```
- not(A and B) = not A and not B
- not(A or B) = not A or not B

```sql
# 업무 중에서 PRESIDENT는 제외하고, 업무별 사원수를 출력. 업무별 사원수가 3명 이상인 업무들만 출력
select job, count(*) as "COUNT"
from emp
where job != 'PRESIDENT'
group by job
having count(*) >= 3  # select에서 설정한 별명 COUNT 사용 불가능
order by count(*);  # select에서 설정한 별명 COUNT 사용 가능
```
```sql
# 오류나는 문장
select job, count(*) as "COUNT"
from emp
where job != 'PRESIDENT'
group by job
having sal is not null and count(*) >= 3
order by count(*);
```
```sql
# 업무별 직원수, 급여 합계 출력. 입사일이 null인 직원은 제외. 업무별 급여 합계가 5000 이상인 그룹만 출력
select job, count(*) as "COUNT", sum(sal) as "SUM_SAL"
from emp
where hiredate is not null
group by job
having sum(sal) >= 5000
order by "SUM_SAL";
# null은 계산할 수 없어서 hiredate = null, hiredate != null 다 false가 나와서 쓸 수 없다
```
```sql
# 입사연도별 직원수를 출력
select
  to_char(hiredate, 'YYYY') as "YEAR",  # 명시적인 타입변환(암묵적인 타입변환은 환경설정에 따라감)
  count(*) as "NUM_OF_EMP"
from emp
group by to_date(hiredate, 'YYYY')
order by "YEAR";
```
- NLS 날짜 포맷 RR/MM/DD hiredate 80/12/17  # str쓰면 80/1까지 잘라줌
- NLS 날짜 포맷 YYYY/MM/DD hiredate 1980/12/17  # str쓰면 1980까지 잘라줌

```sql
# 입사연도별 부서별 직원수를 출력. 1980년은 제외(연도별로 묶어주기 때문에 where, having 둘다 가능)
select
  to_char(hiredate, 'YYYY') as "YEAR",
  deptno,
  count(*) as "COUNT"
from emp
where to_char(hiredate, 'YYYY') != '1980'  # 입사날짜에 null인 직원을 걸러냄
group by to_char(hiredate, 'YYYY'), deptno
order by "YEAR", deptno;
# where to_char(hiredate, ‘YYYY’) != ‘1980’ 대신, having to_char(hiredate, ‘YYYY’) != ‘1980’ 도 같은 결과를 줌
```
```sql
# 부서별 급여 합계
select deptno, sum(sal)
from emp
group by deptno
order by deptno;
```
![image](https://github.com/user-attachments/assets/0bfd4b8a-5235-4e5e-add0-0ee17c1f7b40)
```sql
# 세로로 되어 있는 테이블을 가로로 돌려주기
select
  sum(decode(deptno, 10, sal)) as "10",
  sum(decode(deptno, 20, sal)) as "20",
  sum(decode(deptno, 30, sal)) as "30"
from emp;
```
![image](https://github.com/user-attachments/assets/d77ee696-7d22-4408-bb28-a363f587b67b)
