**복습**
- 부서 테이블(dept)에서 부서 번호, 부서 이름, 위치를 검색
- 컬럼 이름 대신 별명을 사용해서 출력
```sql
select deptno as "부서 번호",
       dename as "부서 이름",
       loc as "위치"
from dept;
```
- 부서 테이블에서 부서 번호와 부서 이름을 ‘10-ACCOUNTING’와 같은 형식으로 출력
```sql
select deptno || '-' || dname as "부서 번호-부서 이름" from dept;
```

## 검색 결과 정렬
- 검색 결과를 (오름차순, 내림차순) 정렬해서 출력:<br>
  **(문법)** select ... from table order by 정렬기준컬럼 [asc/desc], ...;
- asc: ascending order. 오름차순. 기본값. 생략 가능
- desc: descending order. 내림차순
  
- 사번, 이름을 검색, 사번 오름차순 정렬 출력
```sql
select empno, ename
from emp
order by empno;
```
- 사번, 이름, 급여를 급여의 내림차순으로 출력
```sql
select empno, ename, sal
from emp
order by sal desc;
```
- 부서 번호, 사번, 이름을 검색
  - 정렬 조건: (1) 부서 번호 오름차순 (2) 사번 오름차순
```sql
select deptno, empno, ename
from emp
order by deptno, empno;
```
- 부서번호, 이름, 급여를 검색
  - 정렬 조건: (1) 부서번호 오름차순 (2) 급여 내림차순
```sql
select deptno, ename, sal
from emp
order by deptno, sal desc;  # order by deptno asc, sal desc
```

## distinct
- 직원 테이블에서 부서 번호 컬럼 선택 출력
```sql
select deptno from emp;
```
- 직원 테이블에서 중복되지 않는 부서 번호를 검색
```sql
select distinct deptno from emp;
```
- 직원 테이블에서 중복되지 않는 부서 번호/업무를 검색.
```sql
select distinct deptno, job from emp;
# distinct 키워드는 한 번만 사용할 수 있음, 모든 컬럼 다 수식
```

## 조건 검색 where
- 테이블에서 데이터 검색:
  (1) projection: 테이블에서 원하는 컬럼(들) 선택.<br>
      select column1, column2, ...
  (2) selection: 테이블에서 조건을 만족하는 행(들) 선택.<br>
      where 조건식
- **(문법)**: select column1, column2, ... from table where 조건식 order by sort_column, ...;
- 조건식에서 사용되는 연산자들:
  (1) 비교 연산자: =, !=, >, >=, <, <=, is null(비어있는지), is not null, ...
  (2) 논리 연산자: and, or, not
  - 10번 부서에서 근무하는 직원들의 부서번호, 사번, 이름을 검색
```sql
select deptno, empno, ename
from emp
where deptno = 10;
```
![image](https://github.com/user-attachments/assets/e781d644-a439-47e2-b28c-e712eef32069)

- 수당(comm)이 null이 아닌 직원들의 부서번호, 사번, 이름, 급여, 수당을 검색
  - 정렬 순서: (1) 부서번호 오름차순 (2) 사번 오름차순
```sql
select deptno, empno, ename, sal, comm
from emp
where comm is not null  # 0이랑 null이랑 다름. comm != null 하면 안됨
order by deptno, empno; 
```
![image](https://github.com/user-attachments/assets/0db8fa4a-d26b-4674-8ba3-b411b8da8cf5)

**(주의)** SQL에서는 null 여부를 비교할 때 =, != 연산자는 사용할 수 없음.<br>
           반드시 column is null, column is not null을 사용해야 함.
- 급여가 2000 이상 3000 이하인 직원들의 이름, 업무, 급여를 출력
  - 정렬 순서: 급여 내림차순
```sql
select ename, job, sal
from emp
where sal between 2000 and 3000  # 2000과 3000 포함
order by sal desc;

select ename, job, sal
from emp
where sal >= 2000 and sal <= 3000
order by sal desc;
```
![image](https://github.com/user-attachments/assets/513ffc13-18c6-493d-af4c-6dd83715503b)

- 10번 또는 20번 부서에서 근무하는 직원들의 부서번호, 이름, 급여를 출력
  - 정렬: (1) 부서번호 오름차순 (2) 급여 내림차순
```sql
select deptno, ename, sal
from emp
where deptno = 10 or deptno = 20
order by sal desc;

select deptno, ename, sal
from emp
where deptno in (10, 20)  # 값을 쉼표로 구분해서 나열
order by sal desc;
```
![image](https://github.com/user-attachments/assets/1d61e5df-d4cc-42de-9974-55841083b4ca)

- 업무가 ‘CLERK’인 직원들의 이름, 업무, 급여를 출력. 이름순으로 출력
```sql
select ename, job, sal
from emp
where job = 'CLERK'  # 작은 따옴표 써야함
order by ename;
```
![image](https://github.com/user-attachments/assets/bd920d52-a2c5-4e4f-9479-2383c9223a63)

-> SQL에서 문자열은 작은 따옴표(’’)를 사용. 큰따옴표는 별명에만 사용
-> 비교하려는 문자열은 대/소문자를 구분

- 업무가 ‘CLERK’ 또는 ‘MANAGER’인 직원들의 이름, 업무, 급여를 출력
  - 정렬: (1) 업무 (2) 급여
```sql
select ename, job, sal
from emp
where job = 'CLERK' or job = 'MANAGER'
order by job, sal;

select ename, job, sal
from emp
where job in ('CLERK', 'MANAGER')
order by job, sal;
```
![image](https://github.com/user-attachments/assets/57fff791-461a-4c04-9359-b23505ad5ec2)

- 20번 부서에서 근무하는 ‘CLERK’의 모든 레코드(모든 컬럼)를 출력
```sql
select *
from emp
where deptno = 20 and job = 'CLERK'
```
![image](https://github.com/user-attachments/assets/3d4ca8c4-144b-4d09-8c73-e88690787542)

- CLERK, ANALYST, MANAGER가 아닌 직원들의 사번, 이름, 업무, 급여를 사번순 출력
```sql
select empno, ename, job, sal
from emp
where job not in ('CLERK', 'ANALYST', 'MANAGER')
order by empno;
```
![image](https://github.com/user-attachments/assets/e1fde440-8931-4360-95e0-546c09550ae2)

## like 검색
- like 검색: 특정 문자열로 시작하거나 또는 특정 문자열이 포함된 값(들)을 찾는 검색
- like 검색에서 사용되는 wildcard
  (1) %: 글자수 제한 없음.
  (2) _: 밑줄(underscore)이 있는 자리에 한 글자가 어떤 문자이더라도 상관 없음
```sql
select * from emp where job like '_LERK';  # 전체 글자수는 5글자
select *  from emp where job like ‘C%’;  # 글자수 상관없이 'C'로 시작하는 모든 단어
```
- 이름에 ‘A’가 포함된 직원들의 모든 레코드(행과 열)을 출력
```sql
select * from emp where ename like '%A%';
```
![image](https://github.com/user-attachments/assets/172790ef-491c-4149-8ff0-8fe1b2aec0b2)

- 업무에 ‘MAN’ 문자열이 포함된 직원들의 모든 레코드를 출력
```sql
select * from emp where job like '%MAN%'; 
```
- _,%가 포함된 단어를 찾을 때
```sql
select * from emp where job like ‘%\%%’ escape ‘\’;
select * from emp where job like ‘%_\%’ escape ‘\’;
```
-> like ‘%[escaple문자][검색할 특수기호]%’ escape ‘[escape문자]’

```sql
select * from emp where empno = 7369;  # 숫자
select * from emp where empno = ‘7369’;  # 4개의 문자를 가지고 있는 문자열
```
- 오라클에서 숫자 타입 컬럼과 문자열 타입 값을 비교할 때, 문자열을 숫자로 변환한 후 컬럼의 값들과 비교
  - 명시적 타입 변환
  ```sql
  select * from emp where empno = to_number('7369'):
  ```
  - 날짜 타입에서도 크기 비교 가능: 과거(2024년) < 현재(2025년) < 미래(2026년)
  ```sql
  # 1982/01/01 이후에 입사한 직원들
  select * from emp
  where hiredate > '1982/01/01'
  order by hiredate;
  ```
  - where 구문에서 암묵적 타입 변환. 오라클은 날짜(DATE) 타입 컬럼과 문자열을 비교할 때 문자열을 날짜 타입으로 (자동) 변환 후에 컬럼의 값들과 비교
  ```sql
  select * from emp
  where hiredate > '82/01/01'
  order by hiredate;
  # 도구 -> 환경설정 -> 데이터베이스 -> NLS -> 날짜 형식 설정에 따라서 다른 결과를 줌
  ```
  - 날짜 타입으로 명시적 변환: to_date('날짜 문자열', '날짜 포맷')
  - 날짜 포맷에서 연도 표기 YY(현재 세기), RR(관습(반올림)세기: (2000-50)년 ~ (2000+49)년), YYYY
  ```sql
  select to_date(’82/01/01’,’RR/MM/DD’) from dual;  # dual은 오라클에서 쓰는 거

  select to_date(’2025-05-13’,’YYYY-MM-DD’) from dual;  # 날짜 형식이 /로 되어 있어서 결과도 /로

  select to_date(’99-05-13’,’YY-MM-DD’) from dual;  # 2099년 5월 13일

  select to_date(’99-05-13’,’RR-MM-DD’) from dual;  # 1999년 5월 13일

  select to_date(’50-05-13’,’RR-MM-DD’) from dual;  # 1950년 5월 13일

  select to_date(’49-05-13’,’RR-MM-DD’) from dual;  # 2049년 5월 13일
  # 오늘 년도 2025년에서 반올림 했을 때 2100년이 안됨
  # RR 2000-50 ~ 2000+49 = 1950~2049
  # 오늘 년도 1999년에서 반올림 했을 때 2000년이 되어서 똑같은 범위가 됨
  # RR 1950~2049
  # 오늘 년도 2050 반올림하면 2100
  # RR 2100-50 ~ 2100+49 = 2050~2149
  # 즉, 현재 년도를 반올림
  ```
  - 날짜를 문자열로 명시적 변환: to_char(날짜, '날짜 포맷')
  ```sql
  select hiredate from emp;
  ```
  ![image](https://github.com/user-attachments/assets/7c79f38b-f08a-4b4c-979e-f19502c76baa)
  ```sql
  select to_char(hiredate, ‘YYYY-MM-DD’) from emp;
  ```
  ![image](https://github.com/user-attachments/assets/31e46f5e-f68f-4793-bf8f-bf4080987a14)
  ```sql
  select to_char(hiredate, ‘MM-DD-YYYY’) from emp;
  ```
  ![image](https://github.com/user-attachments/assets/05713851-5815-4dfc-acf0-f18ffd757f81)


## 오라클 함수(function)
1. 단일 행 함수: 행(row)이 하나씩 함수의 아규먼트로 전달되고, 행마다 결과값이 반환되는 함수
   - 예) to_date, to_char, to_number, ...
2. 다중 행 함수: 테이블에서 여러 개의 행이 함수의 아규먼트로 전달되고, 하나의 결과값이 반환되는 함수. 통계 관련 함수
   - 예) count, sum, avg, ...

- 단일 행 함수
  - lower(문자열 타입 컬럼) -> 소문자로 변환
  ```sql
  select ename, lower(ename) from emp;  # lower()라는 함수는 결과를 소문자로 만들어서 리턴
  ```
  - upper(문자열 타입 컬럼) -> 대문자로 변환
  ```sql
  select upper(ename) from emp;
  ```

  ```sql
  select * from emp where lower(ename) like ‘%a%’;
  select * from emp where ename like upper(‘%a%’);
  ```
  - initcap(문자열 타입 컬럼) -> 단어의 첫 글자만 대문자, 나머지는 소문자로 변환
  ```sql
  select initcap(ename) from emp;
  ```
  - to_char(컬럼,'포맷'): 컬럼의 값들을 '포맷'형식의 문자열로 변환
  ```sql
  select to_char(hiredate, 'YYYY-MM-DD') from emp;
  ```
  - replace(문자열 컬럼, 원래 문자, 바꿀 문자)
  ```sql
  select replace('smith', 'i', '-') from dual;
  ```
  - substr(문자열 컬럼, 시작 인덱스, 자를 문자 개수)
  ```sql
  select substr('hello', 1, 2) from dual; # 첫 번째 문자부터 두 글자까지 나오게
  select substr(ename, 1, 2) from emp; # 공공데이터 같은 데이터를 제공할 때 감추고 select 할 때 
  ```
