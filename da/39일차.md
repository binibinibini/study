# NumPy 고급기능

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
```

# np.ndarray 속성

```python
arr = np.ones(shape = (2, 3))
print(arr)    # 2차원 배열. 데이터타입은 실수(1.) -> 뒤에 0은 생략
```
![image](https://github.com/user-attachments/assets/2e1f72cb-e079-48a9-b0d8-578656d14320)

```python
arr.shape    # shape 속성: 배열의 각 축(axis)을 따라서 읽는 원소의 개수들의 tuple. (row 개수, column 개수)
```
![image](https://github.com/user-attachments/assets/138884d2-3108-48c4-9a5e-da5b59c306d4)

![image](https://github.com/user-attachments/assets/82525e8c-60b5-47f3-812c-32e078d3c803)

```python
arr.dtype    # dtype 속성: 배열 원소의 데이터 타입.
```
![image](https://github.com/user-attachments/assets/37433e1a-bb2a-4688-806a-09e2448a0e9b)

```python
arr.size    # size 속성: 배열의 모든 원소 개수.
```
![image](https://github.com/user-attachments/assets/b926876b-7a0a-4597-bf2b-7f3f0d2a50cf)

```python
arr.ndim    # ndim: 배열의 차원(dimension). 배열의 축(axis)의 개수.
```
![image](https://github.com/user-attachments/assets/8f96e7db-bd35-4c83-b0a7-089a91c0983a)

```python
arr = np.arange(10)    # 0 이상 10 미만의 (10개의) 정수들로 이루어진 배열.
```
```python
print(arr)
```
![image](https://github.com/user-attachments/assets/88130595-42b1-474c-a75d-df9365bec2bb)

```python
print('dtype:', arr.dtype)
print('ndim:', arr.ndim)
print('shape:', arr.shape)
print('size:', arr.size)
```
![image](https://github.com/user-attachments/assets/d2e945f5-1596-4543-a57f-1811f7bf8281)

# Indexing

```python
print(arr)    # 3d array(3차원 배열)
```
![image](https://github.com/user-attachments/assets/851e894a-b67e-4c04-8af5-8f7188503566)

![image](https://github.com/user-attachments/assets/f25f40e8-54aa-4779-9ae6-b98767cc9083)


```python
print(arr[0])    # 2d array
```
![image](https://github.com/user-attachments/assets/59023ce8-68ee-460e-872f-9d0231aa0d38)

```python
print(arr[0, 0])    # 1d array
```
![image](https://github.com/user-attachments/assets/a724dde2-7e7f-4542-9684-761da96681ec)

```python
print(arr[0][0])
```
![image](https://github.com/user-attachments/assets/6d31406d-f2aa-4518-989b-1d537c94b3a1)

```python
print(arr[0, 0, 0])    # int -> 스칼라(scalar : 원소 한개)
```
![image](https://github.com/user-attachments/assets/563e302c-d922-4c8d-a208-d6b81f1e89bf)

```python
print(arr[0][0][0])
```
![image](https://github.com/user-attachments/assets/f2da78c9-b31e-431a-9aeb-9fba20b7f41c)

*   Python list 인덱스 사용 방법:
    *   `list[i][j][k]...`
*   NumPy ndarray 인덱스 사용 방법:
    *   `array[i, j, k, ...]`
    *   `array[i][j][k]...`

# Slicing

## 1차원 배열의 Slicing

```python
np.random.seed(1)
arr = np.random.randint(100, size = 10)    # [0, 100) 범위의 정수 난수 10개로 이루어진 1d array.
print(arr)
```
![image](https://github.com/user-attachments/assets/db330691-c719-4727-9603-aa1eef95d7f1)

```python
print(arr[1:5])    # (5 - 1 = 4 -> slicing된 원소의 개수)
```
![image](https://github.com/user-attachments/assets/9a61114a-3e43-4caa-ae1e-8de42ffc628a)

```python
print(arr[:3])    # 시작 인덱스 0은 생략 가능
```
![image](https://github.com/user-attachments/assets/c6a23019-9493-4ef8-8b38-a92e4d54ec58)

```python
print(arr[-3:]    # 배열의 끝까지 자를 때는 마지막 인덱스는 생략 가능.
# 배열의 끝에서부터 거꾸로 매기는 인덱스는 음수 인덱스.
```
![image](https://github.com/user-attachments/assets/805b3353-7b43-4b81-a6ef-3b45b52a37dc)

```python
print(arr[0:1])    # slicing의 결과 -> 배열
print(arr[0])    # indexing의 결과 -> 원소 (스칼라)
```
![image](https://github.com/user-attachments/assets/4a4d4cb1-34a8-436c-886a-6b287ad76bc1)

## 2차원 배열의 slicing

```python
arr = np.arange(1, 21).reshape((4, 5))
print(arr)
```
![image](https://github.com/user-attachments/assets/f933a62d-f772-45f2-96b3-45c404278486)

```python
# 2차원 배열 arr의 첫 2개의 1차원 배열
# print(arr[:2])
print(arr[:2, :])
```
![image](https://github.com/user-attachments/assets/7fafd7da-cdb2-45cc-9826-548f56310e92)

```python
# 2차원 배열 arr의 마지막 2개의 1차원 배열
# print(arr[-2:])
print(arr[-2: , :])
```
![image](https://github.com/user-attachments/assets/f6f4436f-9e5a-4108-a9e8-7c361f07e934)

```python
print(arr[:2, :3])
```
![image](https://github.com/user-attachments/assets/203aff85-fdb2-49e0-953c-3fd01d5a9953)

```python
print(arr[1:3, 1:4])
```
![image](https://github.com/user-attachments/assets/7066cc1e-06ee-4e29-b74f-36820d0b7370)

```python
print(arr[1:3][1:4])    # 위쪽 셀의 결과와 비교!
```
![image](https://github.com/user-attachments/assets/8a4ab208-80d8-403e-b133-d36242338035)

## 3차원 배열의 slicing

```python
arr = np.arange(1, 61).reshape((3, 4, 5))
print(arr)
```
![image](https://github.com/user-attachments/assets/d5565715-bb39-4ec3-af82-cf69b45d8b95)

```python
# print(arr[:2, :, :])
print(arr[:2])
```
![image](https://github.com/user-attachments/assets/ea56e510-9696-4122-b26f-ef60e4cfeb36)

```python
# print(arr[:2, :2, :])
print(arr[:2, :2])
```
![image](https://github.com/user-attachments/assets/00bc6aba-288e-4cc8-94ec-adc59657928e)

```python
print(arr[:2, :2, :2])
```
![image](https://github.com/user-attachments/assets/f2ea9d15-0902-4f50-b356-5d6ff6e30e74)

```python
print(arr[:1, :, :])    # 결과: 3d array. (slicing)
```
![image](https://github.com/user-attachments/assets/3338a3f2-538e-4aff-81a2-06e04c0ae8b2)

```python
print(arr[0, :, :])    # 결과: 2d array. (indexing)
```
![image](https://github.com/user-attachments/assets/d4a8ccdd-ea44-4233-948c-e793d0362f1e)

# Shape(모양) 변경
*   `np.ndarray.reshape(arg)`
*   `np.ndarray.ravel()`
*   `np.ndarray.flatten()`
*   `np.newaxis` 속성

## reshape
```python
arr_1d = np.arange(12)
print(arr_1d)
```
![image](https://github.com/user-attachments/assets/f034e1fe-2f14-4359-bc8d-157e8c516f92)

```python
# arr_1d를 (4, 3) shape의 2d array로 변환
arr_2d = arr_1d.reshape((4, 3))
print(arr_2d)
```
![image](https://github.com/user-attachments/assets/cfd2c835-180e-4b99-b8b1-261724b02734)

```python
# reshape 메서드의 아규먼트를 전달할 때 자동으로 계산할 수 있는 차원의 값은 -1을 사용할 수 있음.
arr_2d = arr_1d.reshape((4, -1))    # (4, 3)
print(arr_2d)
```
![image](https://github.com/user-attachments/assets/4d1075f9-3bea-4a40-afdb-82d8c214e1df)

```python
arr_2d = arr_1d.reshape((-1, 4))    # (3, 4). 열을 갯수를 정하면 행을 갯수를 알아서 해
```
![image](https://github.com/user-attachments/assets/d74d207a-a909-450b-acab-260a3d6b3d81)

```python
# 2차원 배열 arr_2d을 1차원 배열로 변환.
result = arr_2d.reshape((12,))    # arr_2d.reshape((3 * 4,))
print(result)
```
![image](https://github.com/user-attachments/assets/38412e8b-9c7d-44b0-af84-192e1628de07)

```python
result = arr_2d.reshape((-1, ))
print(result)
```
![image](https://github.com/user-attachments/assets/792cd183-dd87-4060-b441-ff495c885c6a)

```python
arr_1d = np.arange(60)
print(arr_1d)
```
![image](https://github.com/user-attachments/assets/f2b7258c-29d4-4678-b94a-3ff181c43693)

```python
# 1차원 배열 arr_1d의 모양을 (3, 4, 5)로 변환
result = arr_1d.reshape((3, 4, 5))    # arr_1d.reshape((3, 4, -1))
print(result)
```
![image](https://github.com/user-attachments/assets/721973af-bce8-4cee-84a2-c14ae3f290a4)

```python
# 1차원 배열 arr_1d의 모양을 (5, 4, 3)로 변환
result = arr_1d.reshape((5, 4, -1))    # arr_1d.reshape((5, 4, 3))
print(result)
```
![image](https://github.com/user-attachments/assets/0af5acaa-09e8-49f9-861a-abadafd0fbb3)

## ravel vs flatten

*   flatten
    *   n차원 배열 ndarray를 1차원 배열로 변환한 "복사본"을 리턴.
    *   원본 배열과는 별개의 새로운 배열을 메모리에 만들어서 리턴.
*   ravel
    *   n차원 배열 ndarray를 1차원 배열로 변환한 "뷰(view)"를 리턴.
    *   별개의 새로운 배열을 만드는 것이 아니라, 원본 배열의 모양을 1차원으로 보여줄 뿐.
 
```python
arr_2d = np.arange(12).reshape((3, 4))
print(arr_2d)
```
![image](https://github.com/user-attachments/assets/5991e83c-0cbe-478f-833c-ad1b604ed317)

```python
flattened = arr_2d.flatten()
print(flattened)
```
![image](https://github.com/user-attachments/assets/9cff83e5-1cee-4bd5-8ae2-98ad61f81862)

```python
flattened[0] = 123    # 1차원 배열 flattened의 첫번째 위치에 새로운 값을 재할당.
print(flattened)
```
![image](https://github.com/user-attachments/assets/2b234254-9743-4fc3-801e-d545e95c5a20)

```python
print(arr_2d)    # 원본 2차원 배열과는 무관.
```
![image](https://github.com/user-attachments/assets/efc74af9-473a-4cbb-b535-57bdc5714ffa)

```python
raveled = arr_2d.ravel()
print(raveled)
```
![image](https://github.com/user-attachments/assets/a577476d-0dc9-4811-8325-bdf8632abdfa)

