# 비지도 학습(Unsupervised Learning)

## Imports

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from sklearn.cluster import KMeans
```

# Datasets

[Fruist 360](https://www.kaggle.com/datasets/moltean/fruits): 140, 340개의 과일/채소/견과류 이미지

```python
# 웹에 있는 파일 다운로드
# frurits.npy 저장할 파일 이름
!wget https://bit.ly/fruits_300 -O fruits.npy
```
<img width="895" height="324" alt="image" src="https://github.com/user-attachments/assets/a7f98139-f42c-4d75-aa17-4df8190c30f8" />

*   Jupyter 노트북에서 Linux 명령어를 실행할 때 `!`로 시작.
*   `wget URL주소 -O 파일이름`: URL주소의 파일을 다운로드 받아서 '파일이름'으로 저장.
*   확장자 npy 파일: numpy 배열을 저장한 바이너리 파일.

```python
fruits = np.load('fruits.npy') # npy 형식의 파일을 읽어서 numpy 배열을 만듦.
```
```python
fruits.shape  #> (300, 100, 100) -> (samples, width, height)
```
<img width="117" height="29" alt="image" src="https://github.com/user-attachments/assets/e9bb9ed5-63ae-47f0-bba3-9580d02ad608" />

```
100x100 크기의 흑백 이미지 300개를 numpy 배열로 저장한 데이터셋.
```

## 데이터 시각화

```python
plt.imshow(fruits[0], cmap = plt.cm.binary)  # plt.cm.binary -> plt.cm.gray는 배경이 검은색
plt.show()
```
<img width="395" height="377" alt="image" src="https://github.com/user-attachments/assets/6372db7e-a01c-4c47-949b-1edc6e459201" />

```python
plt.imshow(fruits[100], cmap = plt.cm.binary)
plt.show()
```
<img width="391" height="381" alt="image" src="https://github.com/user-attachments/assets/c5bb7017-077e-4738-bfba-d28fe354a450" />

```python
plt.imshow(fruits[200], cmap = plt.cm.binary)
plt.show()
```
<img width="387" height="380" alt="image" src="https://github.com/user-attachments/assets/23a2753a-382d-4e80-8fd4-d123e4aafb8c" />

```
numpy에는 레이블이 없음
```

```
첫 100개의 이미지를 10개 행, 10개 열로 배치해서 그려보세요.
```
```python
fig, ax = plt.subplots(nrows = 10, ncols = 10, figsize = (10, 10))

for row in range(10):
    for col in range(10):
        ax[row, col].imshow(fruits[row * 10 + col], cmap = plt.cm.binary)
        ax[row, col].axis('off')
plt.show()
```
<img width="610" height="594" alt="image" src="https://github.com/user-attachments/assets/047185f2-c779-4b1a-b349-e734b482c4df" />

```python
fig, ax = plt.subplots(nrows = 10, ncols = 10, figsize = (10, 10))

for row in range(10):
    for col in range(10):
        ax[row, col].imshow(fruits[100 + row * 10 + col], cmap = plt.cm.binary)
        ax[row, col].axis('off')
plt.show()
```
<img width="603" height="597" alt="image" src="https://github.com/user-attachments/assets/48e25b3d-4c0a-4811-9063-ed316e4c2bbe" />

```python
def plot_fruits(n_row = 10, n_col = 10, start = 0):
    fig, ax = plt.subplots(nrows = n_row, ncols = n_col, figsize = (10, 10))
    for row in range(10):
        for col in range(10):
            ax[row, col].imshow(fruits[start + row * 10 + col], cmap = plt.cm.binary)
            ax[row, col].axis('off')
    plt.show()
```
```python
plot_fruits()  # 기본값 사용
```
<img width="599" height="597" alt="image" src="https://github.com/user-attachments/assets/3a2825de-2983-4207-b552-e7519a4b07cf" />

```python
plot_fruits(start = 100)
```
<img width="613" height="598" alt="image" src="https://github.com/user-attachments/assets/c5379ffe-dc55-4fb2-bbe4-4761f1e79c49" />

```python
plot_fruits(start = 200)  # 200 ~ 299
```
<img width="608" height="595" alt="image" src="https://github.com/user-attachments/assets/a50ae917-b997-4e0d-9dc0-841e0b8351fd" />

# 이미지 Pixel 분석

```
(samples, width, height) shape의 3차원 배열을 (samples, width x height) shape의 2차원 배열로 변환
```
```python
fruits_2d = fruits.reshape((300, 100 * 100))  # 2차원 배열로 변환. 300개의 과일 이미지
# fruits_2d = fruits.reshape((300, -1))도 가능
```
```python
fruits_2d.shape
```
<img width="87" height="21" alt="image" src="https://github.com/user-attachments/assets/dd81ed73-70a6-4c37-b450-61c8fcc5074e" />

```python
apples = fruits_2d[:100]  # 사과 이미지
pineapples = fruits_2d[100:200]  # 파인애플 이미지
bananas = fruits_2d[200:]  # 바나나 이미지
```

## 각 샘플에서 모든 픽셀의 평균값

```python
apples.shape
```
<img width="84" height="26" alt="image" src="https://github.com/user-attachments/assets/2ca7cf27-6943-4073-a14b-baa2b4824c6a" />

```python
apple_means = apples.mean(axis = 1)
```
```python
print(apple_means)  # 총 100개. (0 ~ 255) 숫자가 클수록 진한 색
```
<img width="452" height="189" alt="image" src="https://github.com/user-attachments/assets/ed15f447-5692-43c0-ae76-9bec9f2c396d" />

```python
pineapple_means = pineapples.mean(axis = 1)
banana_means = bananas.mean(axis = 1)
```
```python
plt.hist(apple_means, alpha = 0.5, label = 'apple')
plt.hist(pineapple_means, alpha = 0.5, label = 'pineapple')
plt.hist(banana_means, alpha = 0.5, label = 'banana')

plt.legend()
plt.show()
```
<img width="437" height="343" alt="image" src="https://github.com/user-attachments/assets/9c36e5b9-a43f-4573-9070-aa5845134912" />

## 각 픽셀의 평균

<img width="334" height="296" alt="image" src="https://github.com/user-attachments/assets/eee83e06-b1a3-4070-8dca-5c525209c548" />

```
apples.mean(axis = 0) -> 이미지의 가로 방향 밝기 패턴을 보여줌
apples.mean(axis = 1) -> 이미지의 세로 방향 밝기 패턴을 보여줌
```
```python
apple_px_means = apples.mean(axis = 0)
pineapple_px_means = pineapples.mean(axis = 0)
banana_px_means = bananas.mean(axis = 0)
```
```python
print(apple_px_means.shape)
print(pineapple_px_means.shape)
print(banana_px_means.shape)
```
<img width="59" height="49" alt="image" src="https://github.com/user-attachments/assets/3386c215-1301-4f8a-aecd-83fdc88ccd43" />

```python
fig, ax = plt.subplots(nrows = 1, ncols = 3, figsize = (20, 4))
x = range(10_000)
ax[0].bar(x, apple_px_means)  # 막대그래프
ax[0].set_title('apple')

ax[1].bar(x, pineapple_px_means)    
ax[1].set_title('pineapple')

ax[2].bar(x, banana_px_means)    
ax[2].set_title('banana')

plt.show()
```
<img width="1213" height="286" alt="image" src="https://github.com/user-attachments/assets/33f197c0-18c0-4849-a756-05be762dfb1e" />

```
각 픽셀의 평균값(1차원 배열)을 100x100 이미지(2차원 배열)로 생각해서 시각화
```
```python
fig, ax = plt.subplots(nrows = 1, ncols = 3, figsize = (12, 4))
ax[0].imshow(apple_px_means.reshape((100, 100)), cmap = plt.cm.binary)
ax[0].set_title('apple')

ax[1].imshow(pineapple_px_means.reshape((100, 100)), cmap = plt.cm.binary)
ax[1].set_title('pineapple')

ax[2].imshow(banana_px_means.reshape((100, 100)), cmap = plt.cm.binary)
ax[2].set_title('banana')

plt.show()
```
<img width="801" height="272" alt="image" src="https://github.com/user-attachments/assets/2c6d8cfb-5476-47f2-96ff-150d52ff67e5" />

## 각 픽셀의 평균값들과 가까운 이미지 찾기

```python
fruits.shape
```
<img width="100" height="25" alt="image" src="https://github.com/user-attachments/assets/13489fac-c28b-4927-8694-230e7c7ed062" />

```python
apple_px_means. shape
```
<img width="60" height="28" alt="image" src="https://github.com/user-attachments/assets/ba10c961-e582-461f-a54a-ccc0c5b72421" />

```python
diff = np.abs(fruits - apple_px_means.reshape((100, 100)))  # 3차원, 2차원 배열
# 평균 사과 이미지와 모든 과일 이미지 간의 차이 계산
# np.abs는 절대값
# 이걸 통해 사과와 다른 과일들을 구분할 수 있음.
# diff 값이 작으면 원본 이미지가 사과일 가능성이 높음
```
```python
diff.shape
```
<img width="104" height="27" alt="image" src="https://github.com/user-attachments/assets/1fc5afbd-1bf9-46ef-bf19-4e2202a71cb7" />

<img width="432" height="63" alt="image" src="https://github.com/user-attachments/assets/1ceacf73-33ca-4606-932c-dd8a42ae858c" />

```python
diff_mean = np.mean(diff, axis = (1, 2))  # 300개 나옴
# 이미지의 전체 픽셀 차이의 평균값 계산
# axis = (1, 2)를 기준으로 평균을 계산하면, 이미지 하나당 평균 차이값 하나가 나옴
```
<img width="218" height="184" alt="image" src="https://github.com/user-attachments/assets/87d9c7f7-ba1f-49e0-b91a-74e69df12720" />

```python
diff_mean.shape
```
<img width="45" height="26" alt="image" src="https://github.com/user-attachments/assets/747a3c9c-796f-43f5-91cd-3f3a9f543904" />

```python
# 사과 픽셀 평균값과 차이가 작은 순서로 100개의 인덱스
apple_like_idx = np.argsort(diff_mean)[:100]    # np.argsort() 배열을 오름차순으로 정렬하고 인덱스 반환하는 함수
print(apple_like_idx)
```
<img width="526" height="92" alt="image" src="https://github.com/user-attachments/assets/2e48bafb-fa18-47d7-ab2d-b10724b33642" />

```python
fig, ax = plt.subplots(nrows = 10, ncols = 10, figsize = (10, 10))
for row in range(10):
    for col in range(10):
        img = fruits[apple_like_idx[row * 10 + col]]
        ax[row, col].imshow(img, cmap = plt.cm.binary)
        ax[row, col].axis('off')
plt.show()
```
<img width="507" height="495" alt="image" src="https://github.com/user-attachments/assets/d5c8c67a-e40d-4772-8943-60ff0e5b9ef6" />

```
파인애플 이미지들의 각 픽셀 평균값과의 거리가 짧은 샘플
```
```python
diff = np.abs(fruits - pineapple_px_means.reshape((100, 100)))
diff_mean = np.mean(diff, axis = (1, 2))
pineapples_like_idx = np.argsort(diff_mean)[:100]
print(pineapples_like_idx)
```
<img width="457" height="96" alt="image" src="https://github.com/user-attachments/assets/2d19dd55-ad8a-4c2f-874c-66de5fee57a3" />

```python
fig, ax = plt.subplots(nrows = 10, ncols = 10, figsize = (10, 10))
for i in range(10):
    for j in range(10):
        img = fruits[pineapples_like_idx[i * 10 + j]]
        ax[i, j].imshow(img, cmap = plt.cm.binary)
        ax[i, j].axis('off')
plt.show()
```
<img width="500" height="496" alt="image" src="https://github.com/user-attachments/assets/f6916e6f-9629-4e87-b306-712ccd18bd18" />

```
바나나의 픽셀 평균들과 가까운 이미지
```
```python
diff = np.abs(fruits - banana_px_means.reshape((100, 100)))
diff_mean = np.mean(diff, axis = (1, 2))
banana_like_idx = np.argsort(diff_mean)[:100]
print(banana_like_idx)
```
<img width="442" height="95" alt="image" src="https://github.com/user-attachments/assets/7a78f517-600e-4bdc-bff4-354de977af9a" />

```python
fig, ax = plt.subplots(nrows = 10, ncols = 10, figsize = (10, 10))
for i in range(10):
    for j in range(10):
        img = fruits[banana_like_idx[i * 10 + j]]
        ax[i, j].imshow(img, cmap = plt.cm.binary)
        ax[i, j].axis('off')
plt.show()
```
<img width="512" height="496" alt="image" src="https://github.com/user-attachments/assets/0ad0cce7-7448-4eca-a514-da48043304b9" />

# k-Mean 군집(clustering)

1.  무작위로 k개의 클러스터의 중심을 정함.
1.  각 샘플에서 가장 가까운 클러스터 중심을 찾아서 해당 클러스터의 샘플로 지정(군집화).
1.  각 클러스터에 속한 샘플들의 평균값으로 클러스터의 중심을 이동.
1.  바뀐 클러스터 중심으로 2번 과정(군집화)을 수행.
1.  클러스터의 중심이 변하지 않을 때까지 3 ~ 4번 반복.

```python
fruits.shape
```
<img width="100" height="28" alt="image" src="https://github.com/user-attachments/assets/f0ced448-3ada-412d-9d07-37162bd09ba6" />

```python
fruits_2d.shape
```
<img width="81" height="29" alt="image" src="https://github.com/user-attachments/assets/977cbff7-249c-4693-85b2-58316b1946d9" />

```python
# KMeans 클래스 객체 생성
kmeans = KMeans(n_clusters = 3, random_state = 42)    # n_clusters의 갯수는 3
```
```python
# 데이터 학습(훈련) - 비지도 학습: 레이블(y)을 제공하지 않음.
kmeans.fit(X = fruits_2d)    # 레이블말고 특성만 넘겨주기
```
<img width="247" height="64" alt="image" src="https://github.com/user-attachments/assets/30195d57-10ae-4af1-b98e-dcc5d27fda9a" />

```python
kmeans.labels_  # 300개, 0 1 2는 3개의 레이블로 군집화 시킨것
```
<img width="443" height="216" alt="image" src="https://github.com/user-attachments/assets/445d43c9-afd2-4c07-92aa-c4b014b7a2c6" />

```python
np.unique(kmeans.labels_, return_counts = True)
```
<img width="344" height="33" alt="image" src="https://github.com/user-attachments/assets/f7165c4b-1cff-43fa-a74a-5518e82f839d" />

```
KMeans 알고리즘은 300개의 과일 이미지들을 112개, 98개, 90개의 샘플들로 이루어진 3개의 클러스터를 만들어 줌.
```
```python
kmeans.labels_[kmeans.labels_ == 0]    # 112개
```
<img width="449" height="98" alt="image" src="https://github.com/user-attachments/assets/a9930fc4-a4aa-4be6-80eb-6085acc8eb0f" />

```python
fruits[kmeans.labels_ == 0]    # 클러스터 0번에 속한 이미지들만 True로 표시
```
<img width="312" height="722" alt="image" src="https://github.com/user-attachments/assets/ccd8c44e-a193-451d-9278-4aa7a2599258" />

```python
print(len(fruits[kmeans.labels_ == 0]))
print(len(fruits[kmeans.labels_ == 1]))
print(len(fruits[kmeans.labels_ == 2]))
```
<img width="33" height="51" alt="image" src="https://github.com/user-attachments/assets/5329e988-6f71-42c0-8625-d4aa9d277794" />

```python
np.ceil(112 / 10)   # 올림(반올림x)
```
<img width="117" height="25" alt="image" src="https://github.com/user-attachments/assets/7c6dfa9b-6a15-4be5-9752-2e1b2805c9eb" />

```python
def plot_cluster(arr):    # 아규먼트로 배열이 들어옴
    n = len(arr)    # 샘플 개수
    n_cols = 10    # 한 줄에 이미지 10개씩 시각화
    n_rows = int(np.ceil(n / n_cols))    # axis의 행(row) 개수
    fig, ax = plt.subplots(nrows = n_rows, ncols = n_cols, figsize = (n_rows, n_cols))
    for i in range(n_rows):
        for j in range(n_cols):
            idx = i * 10 + j
            if idx < n:     # 배열 인덱스는 배열 원소 개수보다 크면 안되기 때문에
                img = arr[idx]
                ax[i, j].imshow(img, cmap = plt.cm.binary)
            ax[i, j].axis('off')    # 모든 subplot의 축을 제거
    plt.show()
```
```python
plot_cluster(fruits[kmeans.labels_ == 0])
```
<img width="787" height="654" alt="image" src="https://github.com/user-attachments/assets/ca3eead1-e1a9-4b38-b121-c7050d6d07d8" />

```python
plot_cluster(fruits[kmeans.labels_ == 1])   # 98개
# KMeans 알고리즘으로 군집화한 결과 중 클러스터 1번에 속한 데이터만 선택
```
<img width="672" height="662" alt="image" src="https://github.com/user-attachments/assets/079bb127-f8db-4b00-9d49-d8b50d1585e6" />

```python
plot_cluster(fruits[kmeans.labels_ == 2])
```
<img width="603" height="648" alt="image" src="https://github.com/user-attachments/assets/25992ea3-e1f9-4be3-97bc-f27cdad90cd5" />

```
KMeans 알고리즘이 찾은 최종 클러스터 중심
```
```python
kmeans.cluster_centers_
```
<img width="477" height="95" alt="image" src="https://github.com/user-attachments/assets/be043e0b-178d-40af-8dad-1bf7e977d4e3" />

```python
kmeans.cluster_centers_.shape   #> (3, 10000) -> (클러스터 개수, 특성 개수)
```

```python
fig, ax = plt.subplots(nrows = 1, ncols = 3, figsize = (12, 4))
cluster_centers = kmeans.cluster_centers_   # 간단하게 쓰려고 만든거
for i, center in enumerate(cluster_centers):
    ax[i].imshow(center.reshape((100, 100)), cmap = plt.cm.binary)

plt.show()
```
<img width="834" height="276" alt="image" src="https://github.com/user-attachments/assets/312eef90-a0a9-438f-b6e4-89c744a68888" />

<img width="582" height="417" alt="image" src="https://github.com/user-attachments/assets/0bcc9cdf-2fe5-4c14-985c-5b1ea746ddf7" />

<img width="743" height="327" alt="image" src="https://github.com/user-attachments/assets/e9648e6a-7990-442b-ac10-7e522fb01574" />

## 각 샘플에서 클러스터 중심까지의 거리

```python
distances = kmeans.transform(X = fruits_2d)
```
```
distances.shape     #> (300, 3) -> (샘플 개수, 각 클러스터까지의 거리 개수)
```
<img width="61" height="24" alt="image" src="https://github.com/user-attachments/assets/f183d158-b299-4777-9d61-2e271c5f0706" />

```python
distances[0]    #> 첫번째 샘플(이미지)에서 각 클러스터 중심까지의 거리들
```
<img width="336" height="24" alt="image" src="https://github.com/user-attachments/assets/72645dda-97ec-417f-aea5-b6db432afc46" />

```python
predicts = kmeans.predict(X=fruits_2d)
```
```python
predicts.shape  #> (300,) -> 300개 샘플(이미지)의 예측 값.
```
<img width="48" height="31" alt="image" src="https://github.com/user-attachments/assets/24a99462-dbed-4415-bc4f-69fb4fabb62c" />

```python
predicts[0]     #> 가장 짧은 거리의 클러스터로 예측.
```
<img width="76" height="27" alt="image" src="https://github.com/user-attachments/assets/5e7e7491-7ffd-4cd8-b8b2-8a1bef30556c" />

*   `KMeans.transform(X)`: 특성 배열의 샘플에서 각 클러스터 중심까지의 거리들을 리턴.
*   `KMeans.predict(X)`: 가장 가까운 클러스터의 레이블(인덱스)을 리턴.

## 최적의 k값을 찾기

```python
# inertia: 클러스터 중심과 클러스터에 속한 샘플들 사이의 거리들의 제곱의 합.
# 클러스터에 속한 샘플들이 얼마나 가까이 모여 있는 지를 나타내는 값.
kmeans.inertia_
```
<img width="119" height="24" alt="image" src="https://github.com/user-attachments/assets/a1dd1410-9594-4175-8d2d-29eb8ddd5a1b" />

```python
inertias = []   # 클러스터 개수에 따른 inertia들을 저장하기 위한 변수
k_values = np.arange(1, 11)     # 클러스터 개수: 1 ~ 10
# k_values를 사용해서 KMeans 객체 생성 -> 훈련 -> intertia_ 값을 리스트에 저장.
# inertias를 시각화(선 그래프)
for k in k_values:
    kmeans = KMeans(n_clusters=k, random_state = 42)    # 객체 생성
    kmeans.fit(X = fruits_2d)   # 훈련
    inertias.append(kmeans.inertia_)
print(inertias)
```
<img width="1143" height="32" alt="image" src="https://github.com/user-attachments/assets/ee3da70c-a819-46d8-a64f-96634f00e2e9" />

```python
plt.plot(k_values, inertias, 'o-')
plt.xlabel('# of clusters')
plt.ylabel('inertia')
plt.grid()
plt.show()
```
<img width="477" height="373" alt="image" src="https://github.com/user-attachments/assets/a13817ec-6aa3-4bf6-a689-57046c6ed464" />

```
클러스터의 개수를 변화시켜 가면서 계산된 inertia를 시각화해보면 elbow(기울기가 급격하게 바뀌는 부분)가 보이는 경우가 일반적. 그 때의 클러스터 개수가 최적의 클러스 개수.
```



