# 합성곱 시각화


scikit-learn 데이터셋에서 제공되는 예제 이미지 파일의 합성곱 연산 결과를 시각화


```python
import tensorflow as tf
from sklearn.datasets import load_sample_images     # 이미지 두개를 가져올 수 있음
```
```python
sample_images = load_sample_images()
```
```python
type(sample_images)    # Bunch: Python dict와 비슷한 객체. key-value를 갖는 객체.
```
<img width="733" height="400" alt="image" src="https://github.com/user-attachments/assets/3f9dcd9b-2c21-42d6-8622-5797aa049853" />

```python
sample_images.keys()
```
<img width="316" height="31" alt="image" src="https://github.com/user-attachments/assets/fd916da5-e3e7-4c3d-8963-a02653256347" />

```python
print(sample_images.DESCR)
```
<img width="608" height="313" alt="image" src="https://github.com/user-attachments/assets/0ac6c898-4e3f-483c-ac44-7bf5ff4fe6a1" />

```python
images = sample_images.images
# (427, 640, 3) shape의 np.ndarray 2개를 원소로 갖는 리스트(list)
```
```python
fig, ax = plt.subplots(ncols = 2, figsize = (12, 8))  # 가로 세로
for i in range(2):
    ax[i].imshow(images[i])
plt.show()
```
<img width="986" height="330" alt="image" src="https://github.com/user-attachments/assets/f2a2705b-cb00-42ae-9911-b8d6e95b77c8" />

```python
images[0]   # 0 ~ 255까지의 숫자들로 이루어짐
```
<img width="585" height="407" alt="image" src="https://github.com/user-attachments/assets/83ab02f1-c1bc-4312-929e-fd78ae997474" />

```python
# 이미지 자르기 - 이미지의 가운데에서 70x120 크기로 자르기.
images_crop = keras.layers.CenterCrop(height = 70, width = 120)(images)
images_crop.shape
```
<img width="210" height="31" alt="image" src="https://github.com/user-attachments/assets/f1af5996-0436-49cb-a646-dbf49c3db556" />

```python
# 이미지 스케일링 - 모든 픽셀의 값을 0 ~ 1 사이의 범위로 스케일링.
# 픽셀의 값만 바뀌고, 모양은 그대로
images_scaled = keras.layers.Recaling(scale = 1./255)(images_crop)
images_scaled.shape
```
<img width="204" height="30" alt="image" src="https://github.com/user-attachments/assets/68a57ed4-ff6a-4081-975b-193940fd10a1" />

```python
fig, ax = plt.subplots(nrows = 2, figsize = (4, 6))
for i in range(2):
    ax[i].imshow(images_scaled[i])
plt.show()
```
<img width="357" height="480" alt="image" src="https://github.com/user-attachments/assets/e0734e77-4921-4b8f-bcdc-d91c1f8af1eb" />


<img width="697" height="380" alt="image" src="https://github.com/user-attachments/assets/21501d5e-04cb-48e0-8c6e-6cabd0ad02b9" />

```
두개의 필터를 쓸거니깐 한 이미지에 2개의 이미지가 나옴
총 4개가 나오는거
```
```python
# (7, 7, 3) 모양의 필터 2개를 갖는 배열
# 0으로만 채워져있음
filters = np.zeros(shape = (7, 7, 3, 2))    # (7x7), 입력 이미지의 채널 수 3, 생성할 필터의 개수 2
filters[:, 3, :, 0] = 1  # 수직 방향의 값들만 합성곱이 되도록 만든 필터.
filters[3, :, :, 1] = 1  # 수평 방향의 값들만 합성곱이 되도록 만든 필터.
```
<img width="344" height="155" alt="image" src="https://github.com/user-attachments/assets/2eb5b1de-d677-46e9-a1ba-c07c292049a5" />

```python
# 2-D 합성곱 연산 수행
feature_maps = tf.nn.conv2d(input = images_scaled, filters = filters,
                            strides = 1, padding = 'SAME')    # padding = 'SAME' -> 이미지의 크기 그대로 나오도록
feature_maps.shape
# 2 -> 이미지 갯수
# 70, 120 -> 이미지 세로, 가로
# 2 -> filter 2개. output의 갯수
```
<img width="210" height="25" alt="image" src="https://github.com/user-attachments/assets/80de9f6b-04cf-4da1-9c03-a440e7cc37d6" />

```python
# 합성곱 필터가 실제로 어떤 특징을 추출하는지 눈으로 확인하기 위해서
fig, ax = plt.subplots(nrows = 2, ncols = 2, figsize = (12, 7))

for i in range(2):
    for j in range(2):
        ax[i, j].imshow(feature_maps[i, :, :, j])
plt.show()
```
<img width="974" height="586" alt="image" src="https://github.com/user-attachments/assets/8b886f13-accd-4ebb-82df-1bd165fd33f5" />

# 파이썬 클래스 `__call__` magic 메서드. 함수형 API.


클래스의 인스턴스를 함수처럼 사용할 수 있도록 만들어 주는 메서드. 클래스의 객체가 함수와 유사한 동작을 할 수 있도록 기능을 제공.


```python
class Test:
    def __init__(self, value = 0):
        self.value = value      # 객체의 프로퍼티를 초기화.

    def __str__(self):
        return f'Test 객체(value = {self.value})'

    def __repr__(self):
        return f'Test [ value = {self.value} ]'

    # 인스턴스를 함수처럼 호출했을 때 자동으로 호출되는 마법 메서드.
    def __call__(self, value):
        self.value += value
        return self     # 생성된 객체(인스턴스)를 리턴.

    def add(self, x):
        self.value += x
        return self.value
```
```python
# 클래스 Test 타입의 객체를 생성
t = Test()  # 생성자 호출 -> __init__ 호출됨.
```
```python
print(t)    # __str__ 메서드가 리턴하는 문자열로 출력.
```
<img width="152" height="28" alt="image" src="https://github.com/user-attachments/assets/f50de055-2655-431b-9081-1617b544f0b1" />

```python
t        # __repr__ 메서드가 리턴하는 문자열로 출력.
```
<img width="142" height="29" alt="image" src="https://github.com/user-attachments/assets/565d28d5-e3a2-4003-817e-f49f896a6690" />

```python
# 일반적인 메서드는 생성된 객체에서 참조 연산자(.)를 사용해서 호출
t.add(1)
```
<img width="25" height="27" alt="image" src="https://github.com/user-attachments/assets/35ecbe44-8f30-4a79-8fcb-7a793cccfd24" />

```python
t(10)   # 인스턴스를 마치 함수처럼 호출할 수 있음.
```
<img width="149" height="29" alt="image" src="https://github.com/user-attachments/assets/75c44498-c0ef-4892-970d-213a37790bdb" />

```python
t2 = Test(value = 100)(10)   # 100이라는 값을 가지는 객체에 10을 더 준다는거.
```
```python
t2
```
<img width="157" height="29" alt="image" src="https://github.com/user-attachments/assets/68c61df1-1347-47c9-9679-ff7c3749b635" />

```python
Test()(1)(2)(3)
```
<img width="139" height="27" alt="image" src="https://github.com/user-attachments/assets/04f852e6-d996-4540-a225-0fce3ef5d417" />


# 훈련된 합성곱 신경망 시각화

```python
model.layers    # Sequential 객체에 포함된 계층(layer)들
```
<img width="363" height="135" alt="image" src="https://github.com/user-attachments/assets/59b8db12-0879-4d89-ab4e-f6119e19e36d" />

```python
conv1 = model.layers[0]    # layer에서 인덱스 0번 찾기
```
```python
conv1
```
<img width="245" height="35" alt="image" src="https://github.com/user-attachments/assets/aee7a0c7-2549-4638-bdbd-969472c93152" />

```python
# 첫번째 합성곱 층에서 학습된 가중치(모델 파라미터)들
# 가중치 shape : (height, width, channel, n_filters(outputs))
conv1.weights[0].shape
```
<img width="193" height="26" alt="image" src="https://github.com/user-attachments/assets/67203c31-45aa-4a34-8ff8-ff90fa2dfe87" />

```python
# 첫번째 합성곱 층에서 학습된 편향(bias)들
# 편향 shape : (n_filters,)
conv1.weights[1].shape  # 32개
```
<img width="132" height="29" alt="image" src="https://github.com/user-attachments/assets/ddf1bf6a-970d-4889-a94d-c6e896bc2aeb" />

```python
conv1_weights = conv1.weights[0].numpy()    # tf.Tensor --> np.ndarray 변환
```
```python
plt.hist(conv1_weights.reshape((-1,))) # 4차원 배열 --> 1차원 배열로 변환.
plt.xlabel('weights')
plt.ylabel('counts')
plt.show()
```
<img width="562" height="432" alt="image" src="https://github.com/user-attachments/assets/fbed1301-89c4-4940-8f27-afb77f47b7b1" />


훈련된 층의 가중치들은 0을 중심으로 하는 정규분포와 비슷.


```python
# 학습된 필터 가중치들을 시각화
fig, ax = plt.subplots(nrows = 4, ncols = 8, figsize = (8, 4))    # 가로, 세로
for i in range(4):
    for j in range(8):
        idx = i * 8 + j
        ax[i, j].imshow(conv1_weights[:, :, 0, idx], vmin = -0.5, vmax = 0.5)
        # vmin,vmax: plt 모듈에서 컬러맵이 표현하는 숫자 범위.
        ax[i, j].axis('off')
plt.show()
```
<img width="640" height="327" alt="image" src="https://github.com/user-attachments/assets/e4e27fe5-ed9c-45e9-aa10-46848225ab84" />

## 학습되지 않은 가충치들을 시각화

```python
not_trained_model = keras.Sequential()
not_trained_model.add(keras.Input(shape = (28, 28, 1)))
not_trained_model.add(keras.layers.Conv2D(filters = 32, kernel_size = 3,
                                            padding = 'same', activation = 'relu'))
```
```python
not_trained_model.layers
```
<img width="266" height="29" alt="image" src="https://github.com/user-attachments/assets/fb7d48e0-3ebe-43f2-9525-886a321f090b" />

```python
not_trained_weights = not_trained_model.layers[0].weights[0].numpy()
```
```python
not_trained_weights.shape
```
<img width="110" height="27" alt="image" src="https://github.com/user-attachments/assets/6a80eed2-0471-4d2f-89f0-e424454b9f49" />

```python
plt.hist(not_trained_weights.reshape((-1,)))
plt.show()
```
<img width="549" height="413" alt="image" src="https://github.com/user-attachments/assets/e4ea25a9-1d68-46fb-8bd1-1f005b112dfc" />


훈련되지 않은 층의 가중치들은 균등분포에 가까움.


```python
fig, ax = plt.subplots(nrows = 4, ncols = 8, figsize = (8, 4))
for i in range(4):
    for j in range(8):
        idx = i * 8 + j
        ax[i, j].imshow(not_trained_weights[:, :, 0, idx], vmin = -0.5, vmax = 0.5)
        ax[i, j].axis('off')
plt.show()

# 밝은 부분과 어두운 부분이 비슷해서 어떤 패턴을 찾기가 쉽지 않음
```
<img width="640" height="327" alt="image" src="https://github.com/user-attachments/assets/fb8c7e46-a142-4e50-b75f-33c33bff13dc" />

## 합성곱 층을 통과한 이미지 시각화

```python
# 테스트 셋의 첫번째 아이템
plt.imshow(x_test_scaled[0], cmap = plt.cm.binary)
plt.show()
```
<img width="416" height="413" alt="image" src="https://github.com/user-attachments/assets/1b06d903-2962-4203-b209-87d00ec51e87" />

```python
model.inputs
```
<img width="714" height="27" alt="image" src="https://github.com/user-attachments/assets/40bcb6e3-46cd-48c7-bbbe-68c4c6bb7ee4" />

```python
model.layers    # 여기서 첫번째 줄만 필요
```
<img width="355" height="134" alt="image" src="https://github.com/user-attachments/assets/782dc0ae-3085-4e2b-9f51-0f298ab5f885" />

```python
model.layers[0].output
```
<img width="726" height="27" alt="image" src="https://github.com/user-attachments/assets/9f0e3267-f557-4e98-ada0-90147f07c6e5" />

```python
conv1_outputs = keras.Model(model.inputs, model.layers[0].output)
```
```python
conv1_outputs   # Functional API
```
<img width="315" height="25" alt="image" src="https://github.com/user-attachments/assets/6a5cfb03-3a9a-4719-90f3-a408590911c2" />

```python
x_test_scaled[0].shape  # 3차원 텐서
```
<img width="96" height="28" alt="image" src="https://github.com/user-attachments/assets/ded10389-ec74-4e17-87ef-d9acf24cd9dd" />

```python
x_test_scaled[:1].shape
```
<img width="112" height="30" alt="image" src="https://github.com/user-attachments/assets/adc228d5-1b17-4fa5-b499-849f7d58437d" />

```python
feature_maps = conv1_outputs.predict(x_test_scaled[:1])
# 주의: predict 메서드를 호출할 때는 (None, height, width, n_channels) 모양의 텐서를 전달.
```
<img width="427" height="28" alt="image" src="https://github.com/user-attachments/assets/07f30727-85ce-44b7-8bb0-81296171b290" />

```python
feature_maps.shape
```
<img width="121" height="28" alt="image" src="https://github.com/user-attachments/assets/035e2d15-5026-49ce-b5f3-022a1095447f" />

```python
def plot_feature_maps(fmaps, nrows, ncols):
    fig, ax = plt.subplots(nrows, ncols, figsize = (8, 4))
    for i in range(nrows):
        for j in range(ncols):
            idx = i * ncols + j
            ax[i, j].imshow(fmaps[0, :, :, idx], cmap = plt.cm.binary)
            ax[i, j].axis('off')
    plt.show()
```
```python
plot_feature_maps(fmaps = feature_maps, nrows = 4, ncols = 8)
```
<img width="640" height="327" alt="image" src="https://github.com/user-attachments/assets/8fa6d61d-1901-42f8-ba5b-ab3b39508166" />

## 두번째 합성곱 층을 통과한 이미지 시각화

```python
conv2_outputs = keras.Model(model.inputs, model.layers[2].output)
# model.inputs -> (n, 28, 28, 1)가 64개의 필터를 지남. -> (1, 14, 14, 64)
```
```python
feature_maps_2 = conv2_outputs.predict(x_test_scaled[:1])
```
<img width="426" height="29" alt="image" src="https://github.com/user-attachments/assets/4c922cd7-7a30-4f3b-bc77-b82962867360" />

```python
feature_maps_2.shape
```
<img width="117" height="24" alt="image" src="https://github.com/user-attachments/assets/c9d513de-7d57-437f-b62d-1ed60aea20fd" />

```python
plot_feature_maps(fmaps = feature_maps_2, nrows = 8, ncols = 8)
```
<img width="606" height="328" alt="image" src="https://github.com/user-attachments/assets/ed0f516f-254c-4174-b1c6-d3e1336da5e1" />
