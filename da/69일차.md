# Import

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from sklearn import datasets
from sklearn.decomposition import PCA
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import cross_validate
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score    # 정확도 계산
```

# MNIST PCA

## 데이터 셋

```
28 x 28 pixel 숫자 손글씨 이미지 70,000개
```

```python
# fetch_openml은 OpenML이라는 공개 데이터 저장소에서 머신러닝용 데이터 다운로드하는 함수
# as_frame = False -> 데이터를 dataframe이 아닌 numpy 배열로 반환
X, y = datasets.fetch_openml(name = 'mnist_784', return_X_y = True)    # X(입력 데이터), y(타겟 데이터)를 넘파이 배열로 반환
```
```python
X.shape
```
<img width="82" height="27" alt="image" src="https://github.com/user-attachments/assets/261fea58-c1b4-4354-be92-edefa13d66d1" />

```python
y.shape
```
<img width="55" height="22" alt="image" src="https://github.com/user-attachments/assets/be5bb175-9147-4de3-9ca9-140ff64f1e46" />

```python
y.dtype    #> 타겟 배열: 문자열들의 배열. 'o' -> object의 약자
```
<img width="75" height="26" alt="image" src="https://github.com/user-attachments/assets/1d21a912-244a-47f0-9392-d72fa94c6118" />

```python
y = y.astype('int')    # 문자열을 int로 변환('0' -> 0, '1' -> 1, ...)
y.dtype
```
<img width="95" height="26" alt="image" src="https://github.com/user-attachments/assets/6c1dd4ae-6806-435f-9455-cc1095cb8730" />

```python
X
```
<img width="218" height="113" alt="image" src="https://github.com/user-attachments/assets/7e8433a7-4eee-47f4-b44b-625d7c4fe5d2" />

```python
plt.imshow(X[0].reshape((28, 28)), cmap = plt.cm.binary)
plt.show()
```
<img width="416" height="413" alt="image" src="https://github.com/user-attachments/assets/54cd464b-5143-486b-8142-2421ca4f57d8" />

```python
# 훈련 셋(60,000), 테스트 셋(10,000) 분리
X_train, X_test = X[:60_000], X[60_000:]
y_train, y_test = y[:60_000], y[60_000:]
```

## 차원 축소 없이 Random Forest

```python
# RandomForestClassifier 객체 생성(ML 모델 선택)
rand_forest = RandomForestClassifier(random_state = 42)
```
```python
# ML 모델 학습
%%time
rand_forest.fit(X = X_train, y = y_train)
```
<img width="324" height="82" alt="image" src="https://github.com/user-attachments/assets/4d16d620-8a12-4ff2-8e19-3129069264f5" />

```python
# 훈련 셋 예측값
%%time
train_pred = rand_forest.predict(X = X_train)
```
<img width="318" height="37" alt="image" src="https://github.com/user-attachments/assets/088420ce-04be-4c16-9afc-246c50d3c0ad" />

```python
accuracy_score(y_train, train_pred)    # 훈련 셋 정확도
```
<img width="32" height="22" alt="image" src="https://github.com/user-attachments/assets/62aaa437-95a2-4f01-affe-e9e7cb6e4d54" />

```python
# 테스트 셋 예측값(과적합이 얼마나 일어나는지 보기 위해서)
%%time
test_pred = rand_forest.predict(X = X_test)
```
<img width="317" height="37" alt="image" src="https://github.com/user-attachments/assets/129e8aec-eaf5-4895-be56-92ca8215f0ed" />

```python
accuracy_score(y_test, test_pred)    # 테스트 셋 정확도
```
<img width="55" height="29" alt="image" src="https://github.com/user-attachments/assets/b0c38d43-6d0d-47de-9562-dba1d9162825" />

## 차원 축소 후 Random Forest

```
95% 설명된 분산 비율을 갖도록 PCA를 수행.
```
```python
pca = PCA(n_components = 0.95, random_state = 42)  # PCA 객체 생성
```
```python
X_train_reduced = pca.fit_transform(X_train)    # 훈련 셋 차원 축소
```
```python
X_train_reduced.shape
#> (60_000, 784) --> (60_000, 154) 차원 축소됨.
```
<img width="94" height="31" alt="image" src="https://github.com/user-attachments/assets/e72ec4ca-c27f-4386-a3a2-b8092c6e9224" />

```python
rand_forest2 = RandomForestClassifier(random_state = 42)    # ML 모델 생성
```
```python
%%time
rand_forest2.fit(X = X_train_reduced, y = y_train)
```
<img width="385" height="105" alt="image" src="https://github.com/user-attachments/assets/57119661-2022-49f3-ada1-c09d3f83e5bc" />

```
PCA로 차원 축소를 실행하는 것이 항상 훈련 속도를 빠르게 하는 것은 아니다. 훈련 속도는 데이터 셋과 훈련 알고리즘에 따라서 영향을 받는다.
```
```python
# 훈련 셋 예측값
%%time
train_pred = rand_forest2.predict(X = X_train_reduced)  # 예측할 때도 차원 축소된걸로 예측해야 함
```
<img width="378" height="39" alt="image" src="https://github.com/user-attachments/assets/8f69e1ad-6a22-4583-97ad-c2440f0e7528" />

```python
accuracy_score(y_train, train_pred)  # 훈련 셋 정확도
```
<img width="35" height="28" alt="image" src="https://github.com/user-attachments/assets/fbbf7578-17f1-4066-a56d-820705ee1e7e" />

```python
# 테스트 셋 예측값을 찾기 위해서 테스트 셋도 훈련 셋과 동일하게 차원을 축소해야 됨.
X_test_reduced = pca.transform(X = X_test)  # 테스트 셋에서는 fit_transform 말고 transform 사용해야 함
```
```python
# 테스트 셋 예측값
%%time
test_pred = rand_forest2.predict(X = X_test_reduced)
```
<img width="349" height="41" alt="image" src="https://github.com/user-attachments/assets/b914b5f4-75af-4daa-a9a0-3744bd33d2ed" />

```python
accuracy_score(y_test, test_pred)
```
<img width="65" height="32" alt="image" src="https://github.com/user-attachments/assets/20e59316-b99c-4583-896b-b65285679de2" />

```
Random Forest인 경우 PCA를 사용한 차원 축소 적용했을 때 모델 성능(정확도)도 떨어짐.
```

## 차원 축소 없이 SGDClassifier

```python
sgd = SGDClassifier(random_state = 42)  # 모델 생성
```
```python
%%time
sgd.fit(X = X_train, y = y_train)  # 모델 훈련
```
<img width="393" height="95" alt="image" src="https://github.com/user-attachments/assets/4779c47e-1499-4601-8f9e-6d19bb3e515a" />

```python
sgd.intercept_  # 절편
```
<img width="504" height="55" alt="image" src="https://github.com/user-attachments/assets/faffbee6-9c45-4745-ac1f-e75745624427" />

```python
sgd.coef_  # 계수들
```
<img width="280" height="121" alt="image" src="https://github.com/user-attachments/assets/3dd18424-4259-42e5-9787-cd5095133c9f" />

```python
sgd.coef_.shape
```
<img width="82" height="36" alt="image" src="https://github.com/user-attachments/assets/5100dec9-e1f4-4038-9109-3717e430b008" />

```python
train_pred = sgd.predict(X_train)  # 훈련 셋 예측값
```
```python
accuracy_score(y_train, train_pred)  # 훈련 셋 정확도
```
<img width="147" height="25" alt="image" src="https://github.com/user-attachments/assets/401595d4-7745-4b68-9aee-fe968500cd3c" />

```python
test_pred = sgd.predict(X_test)  # 테스트 셋 예측값
accuracy_score(y_test, test_pred)  # 테스트 셋 정확
```
<img width="57" height="26" alt="image" src="https://github.com/user-attachments/assets/c3e8f033-bb14-46ab-ab98-87fae326ff02" />

## 차원 축소 후 SGDClassifier

```python
pca = PCA(n_components = 0.95, random_state = 42)
```
```python
X_train_reduced = pca.fit_transform(X_train)  # 주성분들을 찾고, 차원 축소.
```
```python
X_train_reduced.shape
```
<img width="96" height="33" alt="image" src="https://github.com/user-attachments/assets/42e732f6-dadf-41ce-b46c-39ba5d77e64e" />

```python
pca.n_components_  # 주성분(principal components) 개수
```
<img width="98" height="25" alt="image" src="https://github.com/user-attachments/assets/07359722-257c-4a14-a0ce-b3f8c66d96eb" />

```python
sgd2 = SGDClassifier(random_state = 42)
```
```python
sgd2.fit(X = X_train_reduced, y = y_train)
```
<img width="377" height="92" alt="image" src="https://github.com/user-attachments/assets/7cfbb439-420e-42c6-a9cf-5f4ffb902fc4" />

```python
sgd2.intercept_.shape
```
<img width="51" height="34" alt="image" src="https://github.com/user-attachments/assets/b3ced3bf-e746-4009-9864-c786e8ccc701" />

```python
sgd2.coef_.shape
```
<img width="79" height="34" alt="image" src="https://github.com/user-attachments/assets/0bc47a84-297f-4d3b-92cf-d1f8453df91a" />

```python
train_pred = sgd2.predict(X_train_reduced)
accuracy_score(y_train, train_pred)
```
<img width="70" height="26" alt="image" src="https://github.com/user-attachments/assets/dedc5c6c-859e-4095-90ce-ec412592b595" />

```python
X_test_reduced = pca.transform(X_test)      # 테스트 셋의 차원 축소
test_pred = sgd2.predict(X_test_reduced)    # 테스트 셋의 예측값
accuracy_score(y_test, test_pred)           # 테스트 셋 정확도
```
<img width="66" height="30" alt="image" src="https://github.com/user-attachments/assets/d818b886-118b-4c6f-b1d1-d2d6dd373b8f" />

---------
# Artificial Neural Network(인공 신경망)

# Imports

```python
import numpy as np
import matplotlib.pyplot as plt

from sklearn import datasets
from sklearn.linear_model import SGDClassifier
from sklearn.model_selection import cross_validate, train_test_split
from sklearn.metrics import accuracy_score

import tensorflow as tf
import keras
```

# Iris 데이터 셋

```python
data, target = datasets.load_iris(return_X_y = True)  # return_X_y = True는 데이터를 두 부분으로 나눠서 반환
```
```python
target
```
<img width="532" height="125" alt="image" src="https://github.com/user-attachments/assets/6cff6d6b-848b-4543-9721-a53879271523" />

```python
target.dtype
```
<img width="110" height="32" alt="image" src="https://github.com/user-attachments/assets/075cc066-ca5c-40f9-92ba-2bad44a80580" />

## 이진 분류

*   0(setosa)과 0이 아닌(versicolor, virginica) 클래스 분류 문제
*   2개의 특성만 사용.


```python
X = data[:, :2]     # data에서 행은 모두 선택, 열은 첫 2개만 선택.
X.shape     # 150개의 샘플과 2개의 특성
```
<img width="67" height="28" alt="image" src="https://github.com/user-attachments/assets/56482188-6ab4-4e10-b7b6-c9460640cf32" />

```python
y = (target != 0).astype('int')
y  # 0 -> 0, 1 & 2 -> 1 변환
```
<img width="520" height="126" alt="image" src="https://github.com/user-attachments/assets/0c27e6c7-6fd0-4498-8d73-96477fdb6d92" />

## SGD Classifier

```python
# Logistic 손실 함수를 최소화하는 확률적 경사 하강법 분류 모델을 생성.
# 최대 epoch(반복 횟수)를 10회로 설정.
sgd = SGDClassifier(loss = 'log_loss', max_iter = 10, n_jobs = -1, random_state = 42)  # max_iter가 작아지면 훈련 속도가 작아짐
# loss = 'log_loss'는 로지스틱 회귀 사용. max_iter = 10는 전체 데이터셋을 최대 10번 반복하며 학습. n_jobs = -1는 속도 향상
```
```python
sgd.fit(X, y)   # SGD 모델 훈련 
# 손실 함수를 최소로 만들어주는 절편(intercept)과 계수들(coefficient)을 찾는 과정.
```
<img width="523" height="63" alt="image" src="https://github.com/user-attachments/assets/50ae87b2-2ae3-49a3-9f8d-94f066b7f65b" />

```python
sgd.intercept_
```
<img width="165" height="30" alt="image" src="https://github.com/user-attachments/assets/5ba17337-7940-479f-9664-46b54a563f52" />

```python
sgd.coef_  # 2개인 이유는 x1, x2 두 개의 변수가 있어서
```
<img width="286" height="30" alt="image" src="https://github.com/user-attachments/assets/0b55e36c-b6b8-4fcd-b926-dd673d0dea19" />

```python
# 예측 확률
y_prob = sgd.predict_proba(X)
```
```python
y_prob[:5]
```
<img width="307" height="92" alt="image" src="https://github.com/user-attachments/assets/4100a0d5-454d-4c74-abc8-2ec3bf1c10f6" />

```python
y_pred = sgd.predict(X)  # 예측 값
y_pred[:5]
```
<img width="167" height="30" alt="image" src="https://github.com/user-attachments/assets/7696cfba-e629-4e8f-a624-c22076a68210" />

```python
accuracy_score(y, y_pred)
```
<img width="147" height="31" alt="image" src="https://github.com/user-attachments/assets/9da22831-954b-4e25-b2cd-a049fca8833e" />

## 신경망(Neural Network)

```python
inputs = keras.layers.Input(shape = (2,))  # 입력층(input layer). 2개의 특성을 가짐
```
```python
dense = keras.layers.Dense(units = 1, activation = 'sigmoid')  # 출력층(output layer). Dense는 클래스 이름
# keras.layers.Dense -> 완전 연결층. units = 1 -> 뉴런의 개수(1개의 출력값). activation = 'sigmoid' -> 시그모이드 활성화 함수 사용(출력값이 0과 1사이의 확률값)
```
```python
model = keras.Sequential(layers = [inputs, dense])  # 신경망 모델 생성
```
```python
model.summary()
```
<img width="542" height="147" alt="image" src="https://github.com/user-attachments/assets/9e30e26d-4d71-4cf2-a91b-396d731f4ddd" />

```python
# 출력 형태는 (None, 1). None은 배치 크기(입력 샘플 수)에 따라 달라짐. 1은 1개의 출력값 생성
# 찾고자하는 파라미터가 3개
# 훈련할때 찾는 파라미터도 3개
# 시그모이드 함수를 거치면 1이 나와서 (None, 1). 샘플 갯수는 지정 안된 상태. 값은 숫자 1개가 나올거
```
```python
# 신경망 모델 컴파일: optimizer(최적화 알고리즘), loss(손실함수), metrics
model.complie(optimizer = keras.optimizers.SGD(),  # SGD 즉, 확률적 경사 하강법(모델의 가중치를 업데이트하는 방식)
              loss = keras.losses.binary_crossentropy,  # 이진 분류용 손실 함수
              metrics = [keras.metrics.binary_accuracy])  # 이진 분류의 정확도 사용. []는 리스트
```
```python
# 신경망 모델 훈련
model.fit(x = X, y = y, batch_size = 1, epochs = 10)  # 특성배열, 타겟, (batch_size -> 샘플을 몇개 넣을거냐. 한번에 모델이 넣을 샘플 수), 반복 수
```
<img width="734" height="335" alt="image" src="https://github.com/user-attachments/assets/384e425b-21c8-4d7c-8dfc-f64278d493f4" />

```
손실이 크면 정확도는 줄어든다.
```
```python
# 신경망 모델 훈련을 통해서 찾은 파라미터들
model.weights
```
<img width="658" height="57" alt="image" src="https://github.com/user-attachments/assets/c0d337c2-46ec-4146-aaba-b460cc735c5b" />

```
kernel: 가중치 행렬
경로 -> sequential_2/dense_3/kernel
형태 -> shape=(2, 1). 입력 뉴런 2개, 출력 뉴런 1개(2개의 입력값 각각에 대해 하나의 가중치가 있음)
w1에 곱해지는 가중치 1.3535826, w2에 곱해지는 가중치 -2.163352

bias: 편향 벡터
경로 -> sequential_2/dense_3/bias
형태 -> shape=(1,). 출력 뉴런이 1개니깐 편향도 1개
값 -> -0.28245738(w0)
```
```python
# 신경망 모델 평가
model.evaluate(x = X, y = y)  # evaluate 메서드는 5-fold 교차 검증을 수행.
```
<img width="715" height="40" alt="image" src="https://github.com/user-attachments/assets/398ad62c-b4f0-48e1-a5f4-22b71e8d8763" />

```python
# 예측값 - 활성화 함수의 리턴값. 시그모이드 함수의 리턴값. 클래스가 1이 될 확률.
y_pred = model.predict(X)
```
<img width="439" height="29" alt="image" src="https://github.com/user-attachments/assets/9edbd7d5-e402-40a1-a494-f1533de32369" />

```python
# 숫자 하나씩 가지고 있는 2차원 배열. 위 표에서 (None, 1) 부분
y_pred
```
```
array([[0.2787002 ],
       [0.46506736],
       [0.3008305 ],
       [0.31813234],
       [0.21372585],
       [0.19620505],
       [0.19601735],
       [0.29526642],
       [0.35424882],
       [0.41185716],
       [0.2733855 ],
       [0.24219958],
       [0.43160227],
       [0.27846113],
       [0.25254476],
       [0.11048605],
       [0.19620505],
       [0.2787002 ],
       [0.3126468 ],
       [0.1679923 ],
       [0.41860357],
       [0.20043333],
       [0.13657369],
       [0.3732621 ],
       [0.24219958],
       [0.4988499 ],
       [0.29526642],
       [0.306707  ],
       [0.354521  ],
       [0.3008305 ],
       [0.3795046 ],
       [0.41860357],
       [0.10778476],
       [0.12743503],
       [0.41185716],
       [0.3923914 ],
       [0.39903566],
       [0.19186002],
       [0.3064541 ],
       [0.32418975],
       [0.25232008],
       [0.69697934],
       [0.22280054],
       [0.25232008],
       [0.1679923 ],
       [0.43160227],
       [0.1679923 ],
       [0.273149  ],
       [0.247336  ],
       [0.34217742],
       [0.9063528 ],
       [0.81118745],
       [0.91300344],
       [0.8990341 ],
       [0.9211768 ],
       [0.7982799 ],
       [0.75139236],
       [0.7609787 ],
       [0.91509277],
       [0.714047  ],
       [0.8964837 ],
       [0.7709396 ],
       [0.95604604],
       [0.8456229 ],
       [0.73572844],
       [0.88895935],
       [0.691587  ],
       [0.84906304],
       [0.96611726],
       [0.8686671 ],
       [0.68588555],
       [0.8718047 ],
       [0.94462883],
       [0.8718047 ],
       [0.8915576 ],
       [0.89670444],
       [0.94606435],
       [0.90858585],
       [0.8271151 ],
       [0.85915005],
       [0.87763274],
       [0.87763274],
       [0.84906304],
       [0.8805857 ],
       [0.6310753 ],
       [0.6186074 ],
       [0.88895935],
       [0.9633641 ],
       [0.691587  ],
       [0.8524399 ],
       [0.8231057 ],
       [0.81522727],
       [0.87474793],
       [0.81902355],
       [0.8110051 ],
       [0.7196865 ],
       [0.761195  ],
       [0.8624789 ],
       [0.77072924],
       [0.7982799 ],
       [0.75139236],
       [0.84906304],
       [0.94469106],
       [0.8777606 ],
       [0.88347673],
       [0.97110355],
       [0.7194465 ],
       [0.9652757 ],
       [0.96701515],
       [0.84227717],
       [0.8310523 ],
       [0.92685956],
       [0.91922385],
       [0.88335407],
       [0.81920004],
       [0.81118745],
       [0.88347673],
       [0.87207043],
       [0.98917925],
       [0.95604604],
       [0.89421487],
       [0.7756022 ],
       [0.9834184 ],
       [0.91713655],
       [0.8385508 ],
       [0.92694014],
       [0.88618684],
       [0.81522727],
       [0.910771  ],
       [0.9513523 ],
       [0.9753175 ],
       [0.89935774],
       [0.910771  ],
       [0.8991421 ],
       [0.912909  ],
       [0.97466904],
       [0.7088316 ],
       [0.84211916],
       [0.7939633 ],
       [0.91300344],
       [0.88895935],
       [0.91300344],
       [0.84906304],
       [0.8807108 ],
       [0.8385508 ],
       [0.90858585],
       [0.94462883],
       [0.88347673],
       [0.6801274 ],
       [0.7709396 ]], dtype=float32)
```
```python
y_pred.shape
```
<img width="69" height="26" alt="image" src="https://github.com/user-attachments/assets/d8bb080d-760d-4506-95fc-b55ab1970843" />

```python
# 예측 레이블
y_pred_label = (y_pred > 0.5).astype('int').ravel()  # ravel() -> 2차원 배열을 1차원으로 바꿔주는 함수
y_pred_label
# y_pred > 0.5는 모델이 출력한 확률값 배열. 0.5를 기준으로 이진 분류 수행
```
<img width="514" height="118" alt="image" src="https://github.com/user-attachments/assets/5003ad80-622b-460e-b265-20afabc348f8" />

## 은닉층(hidden layer)을 가지고 있는 신경망

```python
inputs = keras.layers.Input(shape = (2,))   # 입력층
dense1 = keras.layers.Dense(units = 2, activation='sigmoid')    # 은닉층
dense2 = keras.layers.Dense(units = 1, activation='sigmoid')    # 출력층
```
```python
# 위 3개의 계층 연결
model = keras.Sequential(layers = [inputs, dense1, dense2])
```
```python
model.summary()
```
<img width="557" height="177" alt="image" src="https://github.com/user-attachments/assets/676c686c-4f2b-46ed-9e87-e434d4120c13" />

```
첫 번째 Dense 층
출력 뉴런 수: 2개(배치 크기와 상관없이 2개의 출력값 생성)
파라미터 수: 6개

두 번째 Dense 층
출력 뉴런 수: 1개
파라미터 수: 3개
```
```python
# 모델 컴파일 : 
# 어떤 손실함수(loss)를 어떤 평가 기준(metrics)으로 어떻게 최적화(optimizer)할 것인 지를 설정
model.compile(optimizer = keras.optimizers.SGD(),
              loss = keras.losses.binary_crossentropy,
              metrics = [keras.metrics.binary_accuracy])
```
```python
# 모델 훈련
model.fit(X, y, batch_size=1, epochs=1_000, verbose = 0)    # verbose는 epochs의 진행 출력문 없이 보여주는 거
```
<img width="409" height="27" alt="image" src="https://github.com/user-attachments/assets/47363bf2-b80a-471b-8856-c15fd1f4867b" />

```python
model.weights
```
<img width="754" height="105" alt="image" src="https://github.com/user-attachments/assets/0a54bf51-4059-49bb-ae18-a0df8b88f774" />

```
dense_4: 은닉층(입력 2개, 출력 2개)
dense_5: 출력층(입력 2개, 출력 1개)
```
```python
# 예측값 찾기
y_pred = model.predict(X)
```
<img width="421" height="26" alt="image" src="https://github.com/user-attachments/assets/3ca5b302-c1c1-4af0-a0da-6b96753a9a19" />

```python
# 1차원 배열로 보고 싶을 때
y_pred_label = (y_pred > 0.5).astype('int').ravel()
y_pred_label
```
<img width="531" height="122" alt="image" src="https://github.com/user-attachments/assets/c01b5dad-3d78-4991-823d-3efb809880b8" />

```python
np.mean(y == y_pred_label)
```
<img width="231" height="28" alt="image" src="https://github.com/user-attachments/assets/9d2858cc-bb55-4dde-815e-20eba581f4ec" />





