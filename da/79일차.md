# EXAONE-3.5 모델로 텍스트 생성하기

```python
# EXAONE-3.5 모델에서 사용하는 토크나이저 객체를 로딩
exaone_tokenizer = transformers.AutoTokenizer.from_pretrained('LGAI-EXAONE/EXAONE-3.5-2.4B-Instruct')
```
<img width="1320" height="248" alt="image" src="https://github.com/user-attachments/assets/d7bd03ee-c0d4-4c22-abff-e75d89cc1f78" />

```python
# EXAONE-3.5 Pipeline 객체 생성
exaone = transformers.pipeline(task = 'text-generation',    # 수행할 작업의 종류 지정(새로운 문장 생성)
                               model = 'LGAI-EXAONE/EXAONE-3.5-2.4B-Instruct',  # 사용할 모델 이
                               tokenizer = exaone_tokenizer,
                               device = 0,
                               trust_remote_code = True)
```
<img width="1067" height="380" alt="image" src="https://github.com/user-attachments/assets/9c9336cd-8f53-4aa3-a7d9-7892d09b3a19" />

```python
# 메시지 템플릿: 'role'과 'content' 키를 갖는 dict를 원소로 갖는 리스트(list)
# role: 역할(system, user, assistant)
# content: 내용
messages = [
    {
        'role':'system',
        'content':'''너는 쇼핑몰 홈페이지에 올라온 Q&A에 답변을 하는 챗봇이야.
                확정적인 답변을 하지 말고 제품 담당자가 정확한 답변을 하기 위해 시간이
                필요하다는 간단하고 친절한 답변을 생성해줘.'''
    },
    {
        'role':'user',
        'content': '이 다이어리에는 내년도 공휴일 정보가 있나요?'
    }
]
# 두개의 dict를 원소로 갖는 리스트를 만든 거
# 'role':'system' -> 챗봇의 역할 정의
# 'role':'user' -> 사용자가 보낸 메시지
```
```python
result = exaone(messages, max_new_tokens = 200)
# 최대 토큰(단어) 수를 200개로 제한
```
```python
result  # 리턴 값 - dict 1개를 원소로 갖는 list
# dict는 'generated_text' 키와 값 1개로만 이루어진 딕셔너리.
# generated_text의 값(value)은 메시지 프롬프트(dict)들을 가지고 있는 리스트(list)
# generated_text의 가장 마지막 원소가 모델이 생성한 답변.
```
<img width="1794" height="105" alt="image" src="https://github.com/user-attachments/assets/1caff8a0-53ef-4081-8995-42c131107bbe" />

```python
# 리턴값 간단하게 받기
result = exaone(messages, max_new_tokens = 200, return_full_text = False)
# return_full_text = True(기본값): 메시지 프롬프트의 이력이 모두 generated_text의 값으로 리턴. (입력 메시지 + 생성된 텍스트)
# return_full_text = False: generated_text의 값은 모델이 생성한 답변(텍스트)만 포함.

result
```
<img width="1578" height="28" alt="image" src="https://github.com/user-attachments/assets/4c2448d0-92d6-4260-987b-f008073dee20" />

```python
result[0]['generated_text']
```
<img width="1411" height="31" alt="image" src="https://github.com/user-attachments/assets/77838a85-1a67-4c84-b810-96c227d66ba4" />


```
텍스트를 생성할 때마다 토큰들에서 샘플링을 하기 때문에 모델을 실행할 때마다 다른 결과를 줌.
```

```python
result = exaone(messages, max_new_tokens = 200, return_full_text = False, do_sample = False)

# 몇번을 실행해도 답변이 달라지지 않음
```
<img width="943" height="26" alt="image" src="https://github.com/user-attachments/assets/5dc11c7b-8542-4816-8a90-ce682b37c138" />

```python
result[0]['generated_text']
```
<img width="1525" height="30" alt="image" src="https://github.com/user-attachments/assets/cb6149df-5648-440a-b2d0-a648ada6bc61" />


```
`do_sample` 파라미터: 샘플링 전략을 사용할 지 말 지를 설정하는 파라미터. 기본값은 True.

*   `do_sample = True`: 메시지 프롬프트가 같아도 실행할 때마다 생성되는 텍스트가 달라짐.
*   `do_sample = False`:
    *   가장 높은 확률을 갖는 토큰만 선택해서 텍스트를 생성.
    *   메시지 프롬프트가 같으면 항상 생성되는 텍스트가 같음.
*   샘플링 전략(디코딩 전략)
    *   temperature(온도)
    *   top-k 방식
    *   top-p 방식
```

## Temperature

```python
result[0]['generated_text']
```
<img width="1803" height="62" alt="image" src="https://github.com/user-attachments/assets/5ef015d8-c12f-4022-b8f2-1d6c2b426a6c" />

```python
result = exaone(messages, max_new_tokens = 200, return_full_text = False,
                temperature = 0.001)
# temperature가 1보다 작으면 높은 확률을 가진 토큰들이 선택될 가능성이 더 커짐.
# 생성되는 답변이 더 일관적임.
result[0]['generated_text']
```
<img width="1530" height="29" alt="image" src="https://github.com/user-attachments/assets/c9c0ac27-d5a3-4077-a1b9-1e7b0ca53b8b" />

```python
import numpy as np
import scipy
```
```python
# 동전 던지기
probs = [0.5, 0.5]
# pvals의 확률 분포도 n번 실험했을 때 결과 출력
# 정해진 횟수만큼 동전의 앞면과 뒷면 중 하나를 선택하는 과정을 시뮬레이션
np.random.multinomial(n = 100, pvals = probs)

# 앞면 63번, 뒷면 37번
```
<img width="116" height="31" alt="image" src="https://github.com/user-attachments/assets/7451ef55-887d-400b-afa0-2057d058ecb6" />

```python
# 주사위 던지기
probs = [1/6] * 6
np.random.multinomial(n = 100, pvals = probs)
```
<img width="227" height="24" alt="image" src="https://github.com/user-attachments/assets/5581d536-aa60-42a1-bd6e-75d5e8b9bc21" />

```python
# 찌그러진 동전 던지기
probs = [0.7, 0.3]  # 앞면 동전이 더 많이 나옴
np.random.multinomial(n = 100, pvals = probs)
```
<img width="114" height="24" alt="image" src="https://github.com/user-attachments/assets/c8076f40-dca6-4d03-9d02-f2acdea6eef1" />


```
logit: softmax 함수의 아규먼트. LLM에서는 어휘 사전에 포함된 각 토큰에 대한 점수.
```
```python
logits = np.array([1, 2, 3, 4, 100])  # 토큰 5개의 점수
```
```python
# softmax: 점수 -> 확률
probs = scipy.special.softmax(logits)
probs  # 각각의 토큰이 선택될 확률 분포
```
<img width="512" height="39" alt="image" src="https://github.com/user-attachments/assets/48eeaf93-59c2-4e5f-8d3a-22117da0e0c6" />

```python
np.random.multinomial(n = 100, pvals = probs)   # 100번 실험했을 때 각각의 토큰들이 선택될 횟수
```
<img width="236" height="29" alt="image" src="https://github.com/user-attachments/assets/a995adc4-4ffd-497d-8fd2-e1fafb9ed1f1" />

```python
probs = scipy.special.softmax(logits / 10)
print(probs)
np.random.multinomial(n = 100, pvals = probs)
```
<img width="448" height="54" alt="image" src="https://github.com/user-attachments/assets/4b508a1a-96ea-42be-92a7-3bb63ef91317" />

```python
# 더 큰 숫자로 나눌 수록 차이가 줄어든다
probs = scipy.special.softmax(logits / 100)
print(probs)
np.random.multinomial(n = 100, pvals = probs)
```
<img width="411" height="44" alt="image" src="https://github.com/user-attachments/assets/8965e0ce-624e-4ec7-b5f9-dcb9a60d7804" />

```python
probs = scipy.special.softmax(logits / 0.1)
print(probs)
np.random.multinomial(n = 100, pvals = probs)
```
<img width="239" height="45" alt="image" src="https://github.com/user-attachments/assets/51105115-acdb-41cf-bf0a-14597b884299" />


```
*   logit을 1보다 큰 수로 나눈 후 softmax 함수로 확률을 계산하면, logit 값이 작은 토큰들의 확률이 커지는 효과.
    *   토큰을 선택하는 다양성이 커짐.
    *   생성되는 텍스트(답변)이 다양해짐.
*   logit을 1보다 작은 수로 나눈 후 softmax 함수로 확률을 계산하면, logit 값이 큰 토큰들의 확률을 더 크게 만드는 효과.
    *   토큰을 선택하는 다양성이 작아짐.
    *   비슷한 또는 같은 답변이 생성됨.
```

## top-k 샘플링

*   모델이 계산한 logit(점수) 값들을 기준으로 최상위 k개의 토큰을 선택하는 방법.
*   k 값이 클 수록 더 다양한 텍스트들이 생성될 수 있음.



## top-p 샘플링

*   모델이 출력한 logit 값으로 계산한 확률들의 크기 순으로 정렬했을 때 누적 확률 p까지의 토큰들을 선택하는 방법
*   top-k 샘플링은 선택하는 토큰들의 개수를 고정하기 때문에, 높은 확률을 가진 토큰이 선택에서 제외될 가능성이 있음.
*   top-p 샘플링은 누적 확률로 지정하기 때문에 다양한 확률 분포에 유연하게 대처할 수 있음.
