- numpy 문서 참고
https://numpy.org/doc/stable/user/absolute_beginners.html

- pandas 문서 참고
https://pandas.pydata.org/docs/user_guide/index.html

- pandas 책 내용 참고
https://wesmckinney.com/book/


# 데이터 분석 패키지
- NumPy: 다차원 배열을 쉽게 사용할 수 있는 패키지. 머신 러닝에서 중요하게 사용됨.
- pandas: 데이터프레임(DataFrame)과 시리즈(Series)를 기본으로 사용해서 데이터 분석에 필요한 기능들을 가지고 있는 패키지.
- matplotlib, seaborn: 데이터 시각화 패키지. 그래프.
- scikit-learn: 머신 러닝에서 사용하는 패키지.
- keras: 딥러닝에서 사용되는 패키지.

```python
import numpy as np
import pandas as pd
import matplotlib
import seaborn
import sklearn    # scikit-learn
import keras
```
```python
print('numpy version =', np.__version__)
print('pandas version =', pd.__version__)
print('matplotlib version =', matplotlib.__version__)
print('sesborn version =', seaborn.__version__)
print('scikit-learn version =', sklearn.__version__)
print('keras version =', keras.__version__)
```
![image](https://github.com/user-attachments/assets/b54c50e0-e6ee-4000-8e63-503bb0f92f7a)

# Python List
- 여러개의 값들을 저장할 수 있는 데이터 타입
- 인덱스를 기반으로 값들을 저장하는 데이터 타입
  - indexing: 인덱스를 사용해서 원하는 위치의 값을 참조. (예) numbers[0]
  - slicing: [start, end) 인덱스 범위의 부분 리스트를 만듦. (예) numbers[0:5]
- 산술 연산
  - list + list: 두 개의 리스트를 이어붙어서 하나의 리스트로 만듦. concatenate.
  - list * int, int * list: 리스트의 원소들을 정수만큼 복사해서 추가. replicate.

```python
num_list1 = [1, 2, 3]
num_list2 = [11, 22, 33]
```
```python
# indexing
print(num_list1[0])
print(num_list2[-1]
```
![image](https://github.com/user-attachments/assets/cf2bbb45-e465-45ad-a35a-e7d5dd96a112)
```python
# slicing
print(num_list1[:2])
print(num_list2[-2:])
```
![image](https://github.com/user-attachments/assets/a1cfc76d-512f-433f-a169-59a88dbaea90)
```python
num_list1 + num_list2
```
![image](https://github.com/user-attachments/assets/0368a55a-00f2-44ce-a627-35525a354310)
```python
num_list1 * 3
```
![image](https://github.com/user-attachments/assets/92a308f3-9030-44a1-8af1-82bd79a00594)
```python
# num_list1과 num_list2에서 같은 인덱스의 원소들끼리 덧셈
[x + y for x, y in zip(num_list1, num_list2)]
```
![image](https://github.com/user-attachments/assets/7547c1fb-dfa3-4b47-93ce-05d7e13559f2)
```python
# num_list1의 모든 원소에 3을 곱하기
[3 * x for x in num_list1]
```
![image](https://github.com/user-attachments/assets/e02bba31-9309-4eea-b7ed-79778893edd9)
<br>
NumPy(Numerical Python)<br>
- 다차원 배열(n-dimensioal array)을 쉽고 빠르게 연산(+, -, *, /, ...)하기 위한 라이브러리.
- numpy 패키지의 대부분의 기능(연산자, 함수, 메서드)들은 반복문의 기능을 가지고 있음.
  - 같은 인덱스의 원소들끼리(element-wise) 연산하는 기능을 가지고 있음.
- `numpy.ndarray`클래스: numpy 패키지의 가장 기본이 되는 클래스. (ndarray -> n차원 배열)
```python
num_arr1 = np.array([1, 2, 3])  # 아규먼트로 전달된 리스트를 ndarray로 변환해서 리턴.
print(type(num_arr1))
print(num_arr1)  # __str__ 메서드가 리턴하는 문자열
```
![image](https://github.com/user-attachments/assets/323a26a9-d57b-4ff2-93ee-23988968beae)
```python
num_arr2 = np.array([11, 22, 33])
print(num_arr2)
```
![image](https://github.com/user-attachments/assets/a8fe3c53-2d50-4036-ada9-95713b5f9041)
```python
# element-wise 연산
print(num_arr1 + num_arr2)
print(num_arr1 - num_arr2)
print(num_arr1 * num_arr2)
print(num_arr1 * 3)
print(num_arr1 / num_arr2)
```
![image](https://github.com/user-attachments/assets/eb39fd76-b7c2-4cfc-84e2-01a0fb0c47dd)
<br>
## `np.ndarray` 클래스의 속성들
```python
print(num_arr1)
print('ndim =', num_arr1.ndim)  # 차원(dimension)
print('size =', num_arr1.size)  # 배열의 크기(모든 원소 개수)
print('shape =', num_arr1.shape)  # 배열의 모양(배열의 각 차원에서의 원소 객수들로 이루어진 튜플)
print('dtype =', num_arr1.dtype)  # 데이터 타입(배열 원소의 데이터 타입)
```
![image](https://github.com/user-attachments/assets/0082dbf3-757a-4a65-8012-7df40d31f6e4)
- Python의 숫자 타입
  - 정수: int
  - 실수: float
- NumPy의 숫자 타입
  - 정수: int8, int16, int32, int64, ...
  - 실수: float16, float32, float64, ...
```python
# 2차원 배열
array = np.array([[1, 2, 3],  # arrray는 list를 배열로 바꿔줌
                 [4, 5, 6]])
print(type(array))
```
![image](https://github.com/user-attachments/assets/d97ac56d-2316-408f-b75d-29c820263467)
```python
print(array)
```
![image](https://github.com/user-attachments/assets/fb629ff6-5449-4678-a774-6b9948d7bf14)
```python
print('ndim =', array.ndim) # 차원(dimension)
print('size =', array.size) # 크기(shpe 튜플의 모든 숫자들을 곱한 값)
print('shape =', array.shape)   # 모양
print('dtype =', array.dtype)
```
![image](https://github.com/user-attachments/assets/e80ae0aa-2037-41c3-a65b-be1af27a5899)
# `np.ndarray`객체 생성 함수들
## `np.array(object)`
- object를 ndarray로 변환해서 리턴.
- objec: 배열과 비슷한 객체들. `list, tuple, ndarray, ...`
```python
# 0 이상 10 미만의 정수들로 이루어진 배열
numbers = np.array[x for x in range(10)]  # range(1, 10, 1)
print(numbers)
```
![image](https://github.com/user-attachments/assets/9adb9ca1-cdb8-4f37-bd04-243223a51c9e)
## np.arange(start, end, step)
- range를 사용해서 array을 생성하는 함수.
- range(start, end, step)와 사용 방법이 동일.
- 1차원 ndarray를 생성
```python
numbers = np.arange(10)
print(numbers)
```
![image](https://github.com/user-attachments/assets/86cbba19-89b9-4d79-a145-530ab4aaa53d)
```python
# 0 이상 10 이하의 짝수들을 원소로 갖는 배열(ndarray)
evens = np.arange(0, 11, 2)
print(evens)
```
![image](https://github.com/user-attachments/assets/ea0dd054-7b86-4ece-ba63-c0d9eef29b48)
## reshape
- `np.ndarray.reshape(newshape)` 메서드
- `np.reshape(array, newshape)` 함수
```python
array = np.arange(12)
print(array)
```
![image](https://github.com/user-attachments/assets/b224819f-f936-4346-a16a-44ec6ea10b2d)
```python
array2 = array.reshape((3, 4))  # 모양 바꾸기. 객체에서 메서드 호출
print(array2)
```
![image](https://github.com/user-attachments/assets/9a83f329-dc3c-48d5-9424-8d81e926e9c9)
```python
print(array)  # array 자체가 바뀐건 아님
```
![image](https://github.com/user-attachments/assets/760d55dd-056d-405f-a110-decf53fb38a0)
```python
array3 = np.reshape(array, (4, 3))  # 함수 호출
print(array3)
```
![image](https://github.com/user-attachments/assets/79e14820-ab04-4d6f-9a31-b0400603803e)
```python
# 메서드 연쇄 호출(chain-call)
array = np.arange(15).reshape((3, 5))
print(array)
```
![image](https://github.com/user-attachments/assets/4a4129ea-8173-41a4-8df2-2dac13b3e179)
## 난수 배열
- `np.random.rand(d0, d1, d2, ...)`
  - [0, 1) 범위의 균등분포(uniform distribution)를 따르는 난수들을 갖는 배열을 생성.
  - 아규먼트 d0, d1, ...: ndarray의 각 차원의 원소 개수.
- `np.random.randn(d0, d1, d2, ...)`
  - 평균이 0이고 표준편차가 1인 표준정규분포(standard normal distribution)를 따르는 난수들을 갖는 배열을 생성.
  - 아규먼트 d0, d1, ...: ndarray의 각 차원의 원소 개수.
- `np.random.randint(low, high, size, dtype)`
  - [low, high) 범위의 정수 난수들을 갖는 배열을 생성.
  - 아규먼트 size: ndarray의 shape(모양)을 정수 또는 튜플로 전달.
  - 아규먼트 dtype: int8, int16, int32, ...
```python
array = np.random.rand(5)
print(array)
```
![image](https://github.com/user-attachments/assets/f11a0098-57ca-4c11-bdcb-3ded9584d6fc)
```python
array = np.random.rand(5, 3)
print(array)
```
![image](https://github.com/user-attachments/assets/d92fcd18-bf7f-4406-8235-831ccbb0ca7c)
```python
array = np.random.randn(5)
print(array)
```
![image](https://github.com/user-attachments/assets/a70bec24-4bef-446b-bbcc-049dc910b008)
```python
array = np.random.randn(5, 3)
print(array)
```
![image](https://github.com/user-attachments/assets/07b1de1a-900d-4aef-9115-c67bdf588d29)
```python
array = np.random.randint(0, 10, size = 5)
print(array)
```
![image](https://github.com/user-attachments/assets/fcd61cb1-b33a-456c-a158-b36c1f816413)
```python
array = np.random.randint(0, 10, size = (5, 3))
print(array)
```
![image](https://github.com/user-attachments/assets/e9dad678-1b29-495c-be77-b2a0d843cbad)
```python
array = np.random.randint(10)  # size = None(기본값)일 때는 난수 1개를 리턴. 배열 안넣고 싶으면 size 생략 가능
print(type(array))
print(array)
```
![image](https://github.com/user-attachments/assets/ddb7b947-3bb9-4487-b812-f28fd25711ab)
# 통계 함수/메서드
- 함수: `np.function_name(ndarray)`
- 메서드: `np.darray.method_name()`
```python
array = np.random.randint(100, size = 10)
print(array)
```
![image](https://github.com/user-attachments/assets/4a2ee44f-69d7-4229-8c4a-be32978c6391)
```python
print('평균:', np.mean(array), array.mean())    # 왼쪽은 함수호출, 오른쪽은 메서드 호출
print('분산:', np.var(array), array.var())  # variance
print('표준편차:', np.std(array), array.std())    # standard deviation
print('최댓값:', np.max(array), array.max())
print('최솟값:', np.min(array), array.min())
print('중앙값:', np.median(array))  # 중앙값은 메서드가 제공되지 않음. 짝수개이면 중간 값 평균. 홀수개이면 중간 값
```
![image](https://github.com/user-attachments/assets/65c7c701-d9ac-41f7-8de3-e3cf5c3d8bab)
```python
np.sort(array)  # 함수 호출 - 원본 배열은 변경하지 않고, 정렬된 "새로운" 배열을 리턴
```
![image](https://github.com/user-attachments/assets/a01033cc-e229-487c-8ada-b66deb8de156)
```python
array.sort()  # 메서드 호출 - 원본 배열을 정렬하고 리턴은 없음. 원본 배열이 변경됨.
print(array)
```
![image](https://github.com/user-attachments/assets/399959a7-7a6b-4b7b-a68b-4b146bd2f32a)
```python
array = np.random.randint(100, size = 10)
print(array)
print(np.argmax(array), array.argmax()) # 배열에서 최댓값의 인덱스를 리턴
print(np.argmin(array), array.argmin()) # 배열에서 최솟값의 인덱스를 리턴
# np.argmax() 앞에 객체가 없어서 함수임
```
![image](https://github.com/user-attachments/assets/2adab898-de3b-448d-ad7f-a1806ce189af)
<br>
2차원 배열에서 통계 함수/메서드
```python
np.random.seed(42)  # 실행할 때마다 항상 같은 난수들을 만들어 내기 위해서.
array = np.random.randint(10, size = (5, 4))
print(array)
```
![image](https://github.com/user-attachments/assets/a90e85dd-575a-4ee3-9090-f1f59f37cd50)
```python
np.sum(array)  # 2차원 배열의 모든 원소들의 합계. array에서 20개의 숫자 다 더하면 96.
```
![image](https://github.com/user-attachments/assets/a0312360-41df-4429-86e1-43e68f861421)
```python
np.sum(array, axis = 0)  # 행의 인덱스가 증가하는 방향으로 원소들의 합계.
```
![image](https://github.com/user-attachments/assets/241ceecd-9f96-47e0-a8b7-4170bd48e1ca)
```python
np.sum(array, axis = 1)  # 컬럼의 인덱스가 증가하는 방향으로 원소들의 합계. 2차원에서는 axis가 2개.
```
![image](https://github.com/user-attachments/assets/351566ac-5fd7-4850-b9da-c564742f8892)

```python
import numpy as np
import pandas as pd
```
# Series
- 한가지 타입의 값 여러개를 저장할 수 있는 1차원 모양의 데이터 타입(클래스).
- 축(axis) 레이블을 가지고 있는 1차원 배열
  - 정수 기반의 인덱스(range)와 축 레이블을 함께 가질 수 있음.
```python
s = pd.Series([1, 2, -3, 4, 5])
```
```python
print(type(S))
```
![image](https://github.com/user-attachments/assets/0af63f2d-7232-4e74-941e-e84a9e7f20ad)
```python
print(s)
```
![image](https://github.com/user-attachments/assets/2915982e-645c-4e71-a39a-ce5055266caf)
```python
s  # 0, 1, 2, 3, 4는 label. series는 label을 가지고 있음.
```
![image](https://github.com/user-attachments/assets/9b159602-080f-4be6-b99f-43ce291895da)
```python
s.index
```
![image](https://github.com/user-attachments/assets/b16ffc18-4b28-4c9e-83c5-d974a4b486ce)
```python
s.values
```
![image](https://github.com/user-attachments/assets/b2be5af6-3e8e-4128-b84b-d06121aea31d)
## indexing, slicing
- iloc: ndarray의 정수 인덱스 기반으로 원소를 참조. 리스트 또는 ndarray에서 사용하는 방법과 동일.
  - 음수 인덱스 사용이 가능
- loc: 축 레이블 기반으로 원소를 참조
  - 음수 인덱스 사용이 불가능
```python
s.iloc[0]  # 시리즈의 첫번째 원소
```
![image](https://github.com/user-attachments/assets/c04e9e68-83ac-48a2-9467-9991ad688529)
```python
s.iloc[-1]  # 시리즈의 마지막 원소
```
![image](https://github.com/user-attachments/assets/bb1dfaff-7e0b-41c1-99e8-6d31c467821f)
```python
s.iloc[4]
```
![image](https://github.com/user-attachments/assets/77c881e9-8c33-46ed-ad8a-2abb43b1611d)
```python
s.loc[0]
```
![image](https://github.com/user-attachments/assets/07d00df0-8969-486d-a8b9-fe9aed1ff841)
```python
s.loc[4]
```
![image](https://github.com/user-attachments/assets/9d551499-bfb8-4f35-bf19-863aabef6d38)
```python
# s.loc[-1]   # 에러남
```
```python
# iloc를 사용한 slicing
s.iloc[0:2]
```
![image](https://github.com/user-attachments/assets/f5a61310-8a26-4b71-8e20-4c631d0ecd86)
```python
# loc를 사용한 slicing
s.loc[0:2]  # loc는 label이 있기 때문에, 시리즈의 label 기반으로 자름
```
![image](https://github.com/user-attachments/assets/c3e7f483-6398-4c2e-bb44-a93a6853ad03)
```python
s.iloc[2:4]
```
![image](https://github.com/user-attachments/assets/c105e15a-bc65-4810-980e-02ef9c9bfbbf)
```python
s.loc[2:3]
```
![image](https://github.com/user-attachments/assets/9ffa67eb-cf08-41f5-95f7-c0f90b2b0e7c)
```python
s = pd.Series(data = [1, 2, -3, -4, 5]
              index = ['a', 'b', 'x', 'y', 'c'])
s
```
![image](https://github.com/user-attachments/assets/19e92dde-4c91-43f1-835c-af1448852d85)
<br>
```python
s.iloc[0]  # ndarray의 정수 인덱스 기반
```
![image](https://github.com/user-attachments/assets/f62862f2-3ba3-4c7e-a403-3fc015d6d9b0)
```python
s.iloc[-1]  # s.iloc[4]
```
![image](https://github.com/user-attachments/assets/597105a5-9928-4de8-b12e-ae704fa64a86)
```python
s.loc['a']  # 레이블 기반의 인덱스
```
![image](https://github.com/user-attachments/assets/2c2359b4-7b6a-49d6-9768-693d76685648)
```python
s.loc['c']
```
![image](https://github.com/user-attachments/assets/ea8005a0-d39c-4981-8cc7-11e221a51d70)
```python
s.loc['a':'b']
```
![image](https://github.com/user-attachments/assets/ad06f5f4-ef41-4d95-ad2a-256a449a30e0)
```python
s.loc['y':'c']
```
![image](https://github.com/user-attachments/assets/965a4549-14ea-4d21-8dbc-d887f259a49f)
<br>
## fancy indexing
```python
s
```
![image](https://github.com/user-attachments/assets/acdba88c-8b54-4e22-bc41-a322e693c191)
```python
s.loc[['a', 'b', 'c']]  # 원하는 부분만 꺼내기
```
![image](https://github.com/user-attachments/assets/79dbcd67-9d6c-4be1-a307-03283371fba1)
```python
s.iloc[[0, 1, 4]]
```
![image](https://github.com/user-attachments/assets/69640ada-6cc2-43e4-a506-b27388734fd0)
## boolean indexing<br>
boolean indexing은 loc 기반으로 동작. iloc는 사용할 수 없음.
```python
s.loc[[True, False, True, False, True]]
```
![image](https://github.com/user-attachments/assets/96e14092-74c3-4e15-9425-0b430964bef2)
```python
s > 0
```
![image](https://github.com/user-attachments/assets/7a83bd27-989d-462d-9600-c72c1cc80e74)
```python
s.loc[s > 0]  시리즈 s의 원소들 중 양수들로만 이루어진 부분집합
```
![image](https://github.com/user-attachments/assets/e1abba27-3272-40e9-ba79-4a0dbae5bc1d)
```python
s.loc[s < 0]  # 음수 원소들만 찾음.
```
![image](https://github.com/user-attachments/assets/dcb87699-afcf-4d93-ae1d-e043ffa4d57e)
```python
s.loc[:'x']
```
![image](https://github.com/user-attachments/assets/770f0eae-7f88-4f46-87ae-b5253b91ec51)
```python
s.loc['x':]
```
![image](https://github.com/user-attachments/assets/699a56d5-653a-4c72-8cb4-de1fc1208859)
```python
s.loc['a']
```
![image](https://github.com/user-attachments/assets/95924889-e4b6-4433-8935-2e2e8dc7ce20)
```python
print(s.loc['a'])
```
![image](https://github.com/user-attachments/assets/a726fe94-5870-4d6f-a21e-b35bc35acf38)
```python
# print(s.loc[-1]) # 오류
```
```python
test_series = pd.Series(data = [1, 10, 100, 1000],
                        index = [1, 2, -1, -2])
test_series
```
![image](https://github.com/user-attachments/assets/cdee13bc-b1e1-4954-af96-cb4c03ce092e)
```python
print(test_series.loc[-1])
```
![image](https://github.com/user-attachments/assets/13e7fcf2-f9f6-423e-8053-b06b9f9d3464)
```python
print(test_series.iloc[-1])
```
![image](https://github.com/user-attachments/assets/8fb92357-f28b-46ed-a4e9-731d48bdeb84)
```python
s[0]  # 명확하게 구분해서 사용하는게 좋음
```
```
/tmp/ipython-input-59-2713226449.py:1: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
  s[0]    # 명확하게 구분해서 사용하는게 좋음
np.int64(1)
```
```python
# 오류
# test_series.loc[test_series < 100]
```
```python
s
```
![image](https://github.com/user-attachments/assets/e61e8a50-7342-4405-b6f0-eddbe2bf33e2)
```python
s.loc[::-1]
```
![image](https://github.com/user-attachments/assets/00fca02a-9f27-4c60-8d91-f6ae7acf1924)
